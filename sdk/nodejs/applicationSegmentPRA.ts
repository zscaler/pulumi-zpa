// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
 * * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)
 *
 * The **zpa_application_segment_pra** resource creates an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as zpa from "@bdzscaler/pulumi-zpa";
 *
 * const _this = new zpa.ApplicationSegmentPRA("this", {
 *     name: "PRA_Example",
 *     description: "PRA_Example",
 *     enabled: true,
 *     healthReporting: "ON_ACCESS",
 *     bypassType: "NEVER",
 *     isCnameEnabled: true,
 *     tcpPortRanges: [
 *         "22",
 *         "22",
 *         "3389",
 *         "3389",
 *     ],
 *     domainNames: [
 *         "ssh_pra.example.com",
 *         "rdp_pra.example.com",
 *     ],
 *     segmentGroupId: thisZpaSegmentGroup.id,
 *     serverGroups: [{
 *         ids: [thisZpaServerGroup.id],
 *     }],
 *     commonAppsDtos: [{
 *         appsConfigs: [
 *             {
 *                 domain: "ssh_pra.example.com",
 *                 applicationProtocol: "SSH",
 *                 applicationPort: "22",
 *                 enabled: true,
 *                 appTypes: ["SECURE_REMOTE_ACCESS"],
 *             },
 *             {
 *                 domain: "rdp_pra.example.com",
 *                 applicationProtocol: "RDP",
 *                 connectionSecurity: "ANY",
 *                 applicationPort: "3389",
 *                 enabled: true,
 *                 appTypes: ["SECURE_REMOTE_ACCESS"],
 *             },
 *         ],
 *     }],
 * });
 * ```
 *
 * ## Import
 *
 * Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.
 *
 * Visit
 *
 * Application Segment can be imported by using `<APPLICATION SEGMENT ID>` or `<APPLICATION SEGMENT NAME>` as the import ID.
 *
 * ```sh
 * $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_id>
 * ```
 *
 * or
 *
 * ```sh
 * $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_name>
 * ```
 */
export class ApplicationSegmentPRA extends pulumi.CustomResource {
    /**
     * Get an existing ApplicationSegmentPRA resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ApplicationSegmentPRAState, opts?: pulumi.CustomResourceOptions): ApplicationSegmentPRA {
        return new ApplicationSegmentPRA(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'zpa:index/applicationSegmentPRA:ApplicationSegmentPRA';

    /**
     * Returns true if the given object is an instance of ApplicationSegmentPRA.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ApplicationSegmentPRA {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ApplicationSegmentPRA.__pulumiType;
    }

    public readonly bypassOnReauth!: pulumi.Output<boolean>;
    /**
     * Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
     * The value NEVER indicates the use of the client forwarding policy.
     */
    public readonly bypassType!: pulumi.Output<string>;
    public readonly commonAppsDtos!: pulumi.Output<outputs.ApplicationSegmentPRACommonAppsDto[]>;
    public readonly configSpace!: pulumi.Output<string | undefined>;
    /**
     * Description of the application.
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * List of domains and IPs.
     */
    public readonly domainNames!: pulumi.Output<string[]>;
    /**
     * Whether Double Encryption is enabled or disabled for the app.
     */
    public readonly doubleEncrypt!: pulumi.Output<boolean>;
    public readonly enabled!: pulumi.Output<boolean>;
    public readonly fqdnDnsCheck!: pulumi.Output<boolean | undefined>;
    public readonly healthCheckType!: pulumi.Output<string | undefined>;
    /**
     * Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
     */
    public readonly healthReporting!: pulumi.Output<string | undefined>;
    public readonly icmpAccessType!: pulumi.Output<string>;
    public readonly ipAnchored!: pulumi.Output<boolean | undefined>;
    /**
     * Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
     * connectors.
     */
    public readonly isCnameEnabled!: pulumi.Output<boolean>;
    public readonly isIncompleteDrConfig!: pulumi.Output<boolean>;
    public readonly microtenantId!: pulumi.Output<string>;
    /**
     * Name of the application.
     */
    public readonly name!: pulumi.Output<string>;
    public readonly passiveHealthEnabled!: pulumi.Output<boolean>;
    public readonly segmentGroupId!: pulumi.Output<string>;
    public readonly selectConnectorCloseToApp!: pulumi.Output<boolean | undefined>;
    public readonly serverGroups!: pulumi.Output<outputs.ApplicationSegmentPRAServerGroup[] | undefined>;
    public readonly tcpKeepAlive!: pulumi.Output<string>;
    /**
     * tcp port range
     */
    public readonly tcpPortRange!: pulumi.Output<outputs.ApplicationSegmentPRATcpPortRange[]>;
    /**
     * TCP port ranges used to access the app.
     */
    public readonly tcpPortRanges!: pulumi.Output<string[]>;
    /**
     * udp port range
     */
    public readonly udpPortRange!: pulumi.Output<outputs.ApplicationSegmentPRAUdpPortRange[]>;
    /**
     * UDP port ranges used to access the app.
     */
    public readonly udpPortRanges!: pulumi.Output<string[]>;
    public readonly useInDrMode!: pulumi.Output<boolean>;

    /**
     * Create a ApplicationSegmentPRA resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ApplicationSegmentPRAArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ApplicationSegmentPRAArgs | ApplicationSegmentPRAState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ApplicationSegmentPRAState | undefined;
            resourceInputs["bypassOnReauth"] = state ? state.bypassOnReauth : undefined;
            resourceInputs["bypassType"] = state ? state.bypassType : undefined;
            resourceInputs["commonAppsDtos"] = state ? state.commonAppsDtos : undefined;
            resourceInputs["configSpace"] = state ? state.configSpace : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["domainNames"] = state ? state.domainNames : undefined;
            resourceInputs["doubleEncrypt"] = state ? state.doubleEncrypt : undefined;
            resourceInputs["enabled"] = state ? state.enabled : undefined;
            resourceInputs["fqdnDnsCheck"] = state ? state.fqdnDnsCheck : undefined;
            resourceInputs["healthCheckType"] = state ? state.healthCheckType : undefined;
            resourceInputs["healthReporting"] = state ? state.healthReporting : undefined;
            resourceInputs["icmpAccessType"] = state ? state.icmpAccessType : undefined;
            resourceInputs["ipAnchored"] = state ? state.ipAnchored : undefined;
            resourceInputs["isCnameEnabled"] = state ? state.isCnameEnabled : undefined;
            resourceInputs["isIncompleteDrConfig"] = state ? state.isIncompleteDrConfig : undefined;
            resourceInputs["microtenantId"] = state ? state.microtenantId : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["passiveHealthEnabled"] = state ? state.passiveHealthEnabled : undefined;
            resourceInputs["segmentGroupId"] = state ? state.segmentGroupId : undefined;
            resourceInputs["selectConnectorCloseToApp"] = state ? state.selectConnectorCloseToApp : undefined;
            resourceInputs["serverGroups"] = state ? state.serverGroups : undefined;
            resourceInputs["tcpKeepAlive"] = state ? state.tcpKeepAlive : undefined;
            resourceInputs["tcpPortRange"] = state ? state.tcpPortRange : undefined;
            resourceInputs["tcpPortRanges"] = state ? state.tcpPortRanges : undefined;
            resourceInputs["udpPortRange"] = state ? state.udpPortRange : undefined;
            resourceInputs["udpPortRanges"] = state ? state.udpPortRanges : undefined;
            resourceInputs["useInDrMode"] = state ? state.useInDrMode : undefined;
        } else {
            const args = argsOrState as ApplicationSegmentPRAArgs | undefined;
            if ((!args || args.domainNames === undefined) && !opts.urn) {
                throw new Error("Missing required property 'domainNames'");
            }
            if ((!args || args.segmentGroupId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'segmentGroupId'");
            }
            resourceInputs["bypassOnReauth"] = args ? args.bypassOnReauth : undefined;
            resourceInputs["bypassType"] = args ? args.bypassType : undefined;
            resourceInputs["commonAppsDtos"] = args ? args.commonAppsDtos : undefined;
            resourceInputs["configSpace"] = args ? args.configSpace : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["domainNames"] = args ? args.domainNames : undefined;
            resourceInputs["doubleEncrypt"] = args ? args.doubleEncrypt : undefined;
            resourceInputs["enabled"] = args ? args.enabled : undefined;
            resourceInputs["fqdnDnsCheck"] = args ? args.fqdnDnsCheck : undefined;
            resourceInputs["healthCheckType"] = args ? args.healthCheckType : undefined;
            resourceInputs["healthReporting"] = args ? args.healthReporting : undefined;
            resourceInputs["icmpAccessType"] = args ? args.icmpAccessType : undefined;
            resourceInputs["ipAnchored"] = args ? args.ipAnchored : undefined;
            resourceInputs["isCnameEnabled"] = args ? args.isCnameEnabled : undefined;
            resourceInputs["isIncompleteDrConfig"] = args ? args.isIncompleteDrConfig : undefined;
            resourceInputs["microtenantId"] = args ? args.microtenantId : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["passiveHealthEnabled"] = args ? args.passiveHealthEnabled : undefined;
            resourceInputs["segmentGroupId"] = args ? args.segmentGroupId : undefined;
            resourceInputs["selectConnectorCloseToApp"] = args ? args.selectConnectorCloseToApp : undefined;
            resourceInputs["serverGroups"] = args ? args.serverGroups : undefined;
            resourceInputs["tcpKeepAlive"] = args ? args.tcpKeepAlive : undefined;
            resourceInputs["tcpPortRange"] = args ? args.tcpPortRange : undefined;
            resourceInputs["tcpPortRanges"] = args ? args.tcpPortRanges : undefined;
            resourceInputs["udpPortRange"] = args ? args.udpPortRange : undefined;
            resourceInputs["udpPortRanges"] = args ? args.udpPortRanges : undefined;
            resourceInputs["useInDrMode"] = args ? args.useInDrMode : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ApplicationSegmentPRA.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ApplicationSegmentPRA resources.
 */
export interface ApplicationSegmentPRAState {
    bypassOnReauth?: pulumi.Input<boolean>;
    /**
     * Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
     * The value NEVER indicates the use of the client forwarding policy.
     */
    bypassType?: pulumi.Input<string>;
    commonAppsDtos?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRACommonAppsDto>[]>;
    configSpace?: pulumi.Input<string>;
    /**
     * Description of the application.
     */
    description?: pulumi.Input<string>;
    /**
     * List of domains and IPs.
     */
    domainNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether Double Encryption is enabled or disabled for the app.
     */
    doubleEncrypt?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    fqdnDnsCheck?: pulumi.Input<boolean>;
    healthCheckType?: pulumi.Input<string>;
    /**
     * Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
     */
    healthReporting?: pulumi.Input<string>;
    icmpAccessType?: pulumi.Input<string>;
    ipAnchored?: pulumi.Input<boolean>;
    /**
     * Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
     * connectors.
     */
    isCnameEnabled?: pulumi.Input<boolean>;
    isIncompleteDrConfig?: pulumi.Input<boolean>;
    microtenantId?: pulumi.Input<string>;
    /**
     * Name of the application.
     */
    name?: pulumi.Input<string>;
    passiveHealthEnabled?: pulumi.Input<boolean>;
    segmentGroupId?: pulumi.Input<string>;
    selectConnectorCloseToApp?: pulumi.Input<boolean>;
    serverGroups?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAServerGroup>[]>;
    tcpKeepAlive?: pulumi.Input<string>;
    /**
     * tcp port range
     */
    tcpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRATcpPortRange>[]>;
    /**
     * TCP port ranges used to access the app.
     */
    tcpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * udp port range
     */
    udpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAUdpPortRange>[]>;
    /**
     * UDP port ranges used to access the app.
     */
    udpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    useInDrMode?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a ApplicationSegmentPRA resource.
 */
export interface ApplicationSegmentPRAArgs {
    bypassOnReauth?: pulumi.Input<boolean>;
    /**
     * Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
     * The value NEVER indicates the use of the client forwarding policy.
     */
    bypassType?: pulumi.Input<string>;
    commonAppsDtos?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRACommonAppsDto>[]>;
    configSpace?: pulumi.Input<string>;
    /**
     * Description of the application.
     */
    description?: pulumi.Input<string>;
    /**
     * List of domains and IPs.
     */
    domainNames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether Double Encryption is enabled or disabled for the app.
     */
    doubleEncrypt?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    fqdnDnsCheck?: pulumi.Input<boolean>;
    healthCheckType?: pulumi.Input<string>;
    /**
     * Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
     */
    healthReporting?: pulumi.Input<string>;
    icmpAccessType?: pulumi.Input<string>;
    ipAnchored?: pulumi.Input<boolean>;
    /**
     * Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
     * connectors.
     */
    isCnameEnabled?: pulumi.Input<boolean>;
    isIncompleteDrConfig?: pulumi.Input<boolean>;
    microtenantId?: pulumi.Input<string>;
    /**
     * Name of the application.
     */
    name?: pulumi.Input<string>;
    passiveHealthEnabled?: pulumi.Input<boolean>;
    segmentGroupId: pulumi.Input<string>;
    selectConnectorCloseToApp?: pulumi.Input<boolean>;
    serverGroups?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAServerGroup>[]>;
    tcpKeepAlive?: pulumi.Input<string>;
    /**
     * tcp port range
     */
    tcpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRATcpPortRange>[]>;
    /**
     * TCP port ranges used to access the app.
     */
    tcpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * udp port range
     */
    udpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAUdpPortRange>[]>;
    /**
     * UDP port ranges used to access the app.
     */
    udpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    useInDrMode?: pulumi.Input<boolean>;
}
