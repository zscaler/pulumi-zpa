// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
 * * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)
 *
 * The **zpa_application_segment_pra** resource creates an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as zpa from "@bdzscaler/pulumi-zpa";
 *
 * const _this = new zpa.ApplicationSegmentPRA("this", {
 *     name: "PRA_Example",
 *     description: "PRA_Example",
 *     enabled: true,
 *     healthReporting: "ON_ACCESS",
 *     bypassType: "NEVER",
 *     isCnameEnabled: true,
 *     tcpPortRanges: [
 *         "22",
 *         "22",
 *         "3389",
 *         "3389",
 *     ],
 *     domainNames: [
 *         "ssh_pra.example.com",
 *         "rdp_pra.example.com",
 *     ],
 *     segmentGroupId: thisZpaSegmentGroup.id,
 *     serverGroups: [{
 *         ids: [thisZpaServerGroup.id],
 *     }],
 *     commonAppsDtos: [{
 *         appsConfigs: [
 *             {
 *                 domain: "ssh_pra.example.com",
 *                 applicationProtocol: "SSH",
 *                 applicationPort: "22",
 *                 enabled: true,
 *                 appTypes: ["SECURE_REMOTE_ACCESS"],
 *             },
 *             {
 *                 domain: "rdp_pra.example.com",
 *                 applicationProtocol: "RDP",
 *                 connectionSecurity: "ANY",
 *                 applicationPort: "3389",
 *                 enabled: true,
 *                 appTypes: ["SECURE_REMOTE_ACCESS"],
 *             },
 *         ],
 *     }],
 * });
 * ```
 *
 * ## Import
 *
 * Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.
 *
 * Visit
 *
 * Application Segment can be imported by using `<APPLICATION SEGMENT ID>` or `<APPLICATION SEGMENT NAME>` as the import ID.
 *
 * ```sh
 * $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_id>
 * ```
 *
 * or
 *
 * ```sh
 * $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_name>
 * ```
 */
export class ApplicationSegmentPRA extends pulumi.CustomResource {
    /**
     * Get an existing ApplicationSegmentPRA resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ApplicationSegmentPRAState, opts?: pulumi.CustomResourceOptions): ApplicationSegmentPRA {
        return new ApplicationSegmentPRA(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'zpa:index/applicationSegmentPRA:ApplicationSegmentPRA';

    /**
     * Returns true if the given object is an instance of ApplicationSegmentPRA.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ApplicationSegmentPRA {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ApplicationSegmentPRA.__pulumiType;
    }

    declare public readonly bypassOnReauth: pulumi.Output<boolean>;
    /**
     * Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET. The value NEVER indicates the use of the client forwarding policy.
     */
    declare public readonly bypassType: pulumi.Output<string>;
    declare public readonly commonAppsDtos: pulumi.Output<outputs.ApplicationSegmentPRACommonAppsDto[]>;
    declare public readonly configSpace: pulumi.Output<string | undefined>;
    /**
     * Description of the application.
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * List of domains and IPs.
     */
    declare public readonly domainNames: pulumi.Output<string[]>;
    /**
     * Whether Double Encryption is enabled or disabled for the app.
     */
    declare public readonly doubleEncrypt: pulumi.Output<boolean>;
    declare public readonly enabled: pulumi.Output<boolean | undefined>;
    declare public readonly fqdnDnsCheck: pulumi.Output<boolean | undefined>;
    declare public readonly healthCheckType: pulumi.Output<string>;
    /**
     * Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
     */
    declare public readonly healthReporting: pulumi.Output<string | undefined>;
    declare public readonly icmpAccessType: pulumi.Output<string>;
    declare public readonly ipAnchored: pulumi.Output<boolean | undefined>;
    /**
     * Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
     */
    declare public readonly isCnameEnabled: pulumi.Output<boolean>;
    declare public readonly isIncompleteDrConfig: pulumi.Output<boolean>;
    declare public readonly microtenantId: pulumi.Output<string>;
    /**
     * Name of the application.
     */
    declare public readonly name: pulumi.Output<string>;
    declare public readonly passiveHealthEnabled: pulumi.Output<boolean>;
    declare public readonly segmentGroupId: pulumi.Output<string>;
    declare public readonly selectConnectorCloseToApp: pulumi.Output<boolean | undefined>;
    declare public readonly serverGroups: pulumi.Output<outputs.ApplicationSegmentPRAServerGroup[] | undefined>;
    declare public readonly tcpKeepAlive: pulumi.Output<string>;
    /**
     * tcp port range
     */
    declare public readonly tcpPortRange: pulumi.Output<outputs.ApplicationSegmentPRATcpPortRange[]>;
    /**
     * TCP port ranges used to access the app.
     */
    declare public readonly tcpPortRanges: pulumi.Output<string[]>;
    /**
     * udp port range
     */
    declare public readonly udpPortRange: pulumi.Output<outputs.ApplicationSegmentPRAUdpPortRange[]>;
    /**
     * UDP port ranges used to access the app.
     */
    declare public readonly udpPortRanges: pulumi.Output<string[]>;
    declare public readonly useInDrMode: pulumi.Output<boolean>;
    declare public readonly zpnErIds: pulumi.Output<outputs.ApplicationSegmentPRAZpnErId[] | undefined>;

    /**
     * Create a ApplicationSegmentPRA resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ApplicationSegmentPRAArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ApplicationSegmentPRAArgs | ApplicationSegmentPRAState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ApplicationSegmentPRAState | undefined;
            resourceInputs["bypassOnReauth"] = state?.bypassOnReauth;
            resourceInputs["bypassType"] = state?.bypassType;
            resourceInputs["commonAppsDtos"] = state?.commonAppsDtos;
            resourceInputs["configSpace"] = state?.configSpace;
            resourceInputs["description"] = state?.description;
            resourceInputs["domainNames"] = state?.domainNames;
            resourceInputs["doubleEncrypt"] = state?.doubleEncrypt;
            resourceInputs["enabled"] = state?.enabled;
            resourceInputs["fqdnDnsCheck"] = state?.fqdnDnsCheck;
            resourceInputs["healthCheckType"] = state?.healthCheckType;
            resourceInputs["healthReporting"] = state?.healthReporting;
            resourceInputs["icmpAccessType"] = state?.icmpAccessType;
            resourceInputs["ipAnchored"] = state?.ipAnchored;
            resourceInputs["isCnameEnabled"] = state?.isCnameEnabled;
            resourceInputs["isIncompleteDrConfig"] = state?.isIncompleteDrConfig;
            resourceInputs["microtenantId"] = state?.microtenantId;
            resourceInputs["name"] = state?.name;
            resourceInputs["passiveHealthEnabled"] = state?.passiveHealthEnabled;
            resourceInputs["segmentGroupId"] = state?.segmentGroupId;
            resourceInputs["selectConnectorCloseToApp"] = state?.selectConnectorCloseToApp;
            resourceInputs["serverGroups"] = state?.serverGroups;
            resourceInputs["tcpKeepAlive"] = state?.tcpKeepAlive;
            resourceInputs["tcpPortRange"] = state?.tcpPortRange;
            resourceInputs["tcpPortRanges"] = state?.tcpPortRanges;
            resourceInputs["udpPortRange"] = state?.udpPortRange;
            resourceInputs["udpPortRanges"] = state?.udpPortRanges;
            resourceInputs["useInDrMode"] = state?.useInDrMode;
            resourceInputs["zpnErIds"] = state?.zpnErIds;
        } else {
            const args = argsOrState as ApplicationSegmentPRAArgs | undefined;
            if (args?.domainNames === undefined && !opts.urn) {
                throw new Error("Missing required property 'domainNames'");
            }
            if (args?.segmentGroupId === undefined && !opts.urn) {
                throw new Error("Missing required property 'segmentGroupId'");
            }
            resourceInputs["bypassOnReauth"] = args?.bypassOnReauth;
            resourceInputs["bypassType"] = args?.bypassType;
            resourceInputs["commonAppsDtos"] = args?.commonAppsDtos;
            resourceInputs["configSpace"] = args?.configSpace;
            resourceInputs["description"] = args?.description;
            resourceInputs["domainNames"] = args?.domainNames;
            resourceInputs["doubleEncrypt"] = args?.doubleEncrypt;
            resourceInputs["enabled"] = args?.enabled;
            resourceInputs["fqdnDnsCheck"] = args?.fqdnDnsCheck;
            resourceInputs["healthCheckType"] = args?.healthCheckType;
            resourceInputs["healthReporting"] = args?.healthReporting;
            resourceInputs["icmpAccessType"] = args?.icmpAccessType;
            resourceInputs["ipAnchored"] = args?.ipAnchored;
            resourceInputs["isCnameEnabled"] = args?.isCnameEnabled;
            resourceInputs["isIncompleteDrConfig"] = args?.isIncompleteDrConfig;
            resourceInputs["microtenantId"] = args?.microtenantId;
            resourceInputs["name"] = args?.name;
            resourceInputs["passiveHealthEnabled"] = args?.passiveHealthEnabled;
            resourceInputs["segmentGroupId"] = args?.segmentGroupId;
            resourceInputs["selectConnectorCloseToApp"] = args?.selectConnectorCloseToApp;
            resourceInputs["serverGroups"] = args?.serverGroups;
            resourceInputs["tcpKeepAlive"] = args?.tcpKeepAlive;
            resourceInputs["tcpPortRange"] = args?.tcpPortRange;
            resourceInputs["tcpPortRanges"] = args?.tcpPortRanges;
            resourceInputs["udpPortRange"] = args?.udpPortRange;
            resourceInputs["udpPortRanges"] = args?.udpPortRanges;
            resourceInputs["useInDrMode"] = args?.useInDrMode;
            resourceInputs["zpnErIds"] = args?.zpnErIds;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ApplicationSegmentPRA.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ApplicationSegmentPRA resources.
 */
export interface ApplicationSegmentPRAState {
    bypassOnReauth?: pulumi.Input<boolean>;
    /**
     * Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET. The value NEVER indicates the use of the client forwarding policy.
     */
    bypassType?: pulumi.Input<string>;
    commonAppsDtos?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRACommonAppsDto>[]>;
    configSpace?: pulumi.Input<string>;
    /**
     * Description of the application.
     */
    description?: pulumi.Input<string>;
    /**
     * List of domains and IPs.
     */
    domainNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether Double Encryption is enabled or disabled for the app.
     */
    doubleEncrypt?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    fqdnDnsCheck?: pulumi.Input<boolean>;
    healthCheckType?: pulumi.Input<string>;
    /**
     * Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
     */
    healthReporting?: pulumi.Input<string>;
    icmpAccessType?: pulumi.Input<string>;
    ipAnchored?: pulumi.Input<boolean>;
    /**
     * Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
     */
    isCnameEnabled?: pulumi.Input<boolean>;
    isIncompleteDrConfig?: pulumi.Input<boolean>;
    microtenantId?: pulumi.Input<string>;
    /**
     * Name of the application.
     */
    name?: pulumi.Input<string>;
    passiveHealthEnabled?: pulumi.Input<boolean>;
    segmentGroupId?: pulumi.Input<string>;
    selectConnectorCloseToApp?: pulumi.Input<boolean>;
    serverGroups?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAServerGroup>[]>;
    tcpKeepAlive?: pulumi.Input<string>;
    /**
     * tcp port range
     */
    tcpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRATcpPortRange>[]>;
    /**
     * TCP port ranges used to access the app.
     */
    tcpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * udp port range
     */
    udpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAUdpPortRange>[]>;
    /**
     * UDP port ranges used to access the app.
     */
    udpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    useInDrMode?: pulumi.Input<boolean>;
    zpnErIds?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAZpnErId>[]>;
}

/**
 * The set of arguments for constructing a ApplicationSegmentPRA resource.
 */
export interface ApplicationSegmentPRAArgs {
    bypassOnReauth?: pulumi.Input<boolean>;
    /**
     * Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET. The value NEVER indicates the use of the client forwarding policy.
     */
    bypassType?: pulumi.Input<string>;
    commonAppsDtos?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRACommonAppsDto>[]>;
    configSpace?: pulumi.Input<string>;
    /**
     * Description of the application.
     */
    description?: pulumi.Input<string>;
    /**
     * List of domains and IPs.
     */
    domainNames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether Double Encryption is enabled or disabled for the app.
     */
    doubleEncrypt?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    fqdnDnsCheck?: pulumi.Input<boolean>;
    healthCheckType?: pulumi.Input<string>;
    /**
     * Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
     */
    healthReporting?: pulumi.Input<string>;
    icmpAccessType?: pulumi.Input<string>;
    ipAnchored?: pulumi.Input<boolean>;
    /**
     * Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
     */
    isCnameEnabled?: pulumi.Input<boolean>;
    isIncompleteDrConfig?: pulumi.Input<boolean>;
    microtenantId?: pulumi.Input<string>;
    /**
     * Name of the application.
     */
    name?: pulumi.Input<string>;
    passiveHealthEnabled?: pulumi.Input<boolean>;
    segmentGroupId: pulumi.Input<string>;
    selectConnectorCloseToApp?: pulumi.Input<boolean>;
    serverGroups?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAServerGroup>[]>;
    tcpKeepAlive?: pulumi.Input<string>;
    /**
     * tcp port range
     */
    tcpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRATcpPortRange>[]>;
    /**
     * TCP port ranges used to access the app.
     */
    tcpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * udp port range
     */
    udpPortRange?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAUdpPortRange>[]>;
    /**
     * UDP port ranges used to access the app.
     */
    udpPortRanges?: pulumi.Input<pulumi.Input<string>[]>;
    useInDrMode?: pulumi.Input<boolean>;
    zpnErIds?: pulumi.Input<pulumi.Input<inputs.ApplicationSegmentPRAZpnErId>[]>;
}
