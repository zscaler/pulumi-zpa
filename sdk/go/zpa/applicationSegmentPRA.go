// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zpa

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zpa/sdk/go/zpa/internal"
)

// The **zpa_application_segment_pra** resource creates an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/zscaler/pulumi-zpa/sdk/go/zpa"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := zpa.NewApplicationSegmentPRA(ctx, "this", &zpa.ApplicationSegmentPRAArgs{
//				Description:     pulumi.String("PRA_Example"),
//				Enabled:         pulumi.Bool(true),
//				HealthReporting: pulumi.String("ON_ACCESS"),
//				BypassType:      pulumi.String("NEVER"),
//				IsCnameEnabled:  pulumi.Bool(true),
//				TcpPortRanges: pulumi.StringArray{
//					pulumi.String("22"),
//					pulumi.String("22"),
//					pulumi.String("3389"),
//					pulumi.String("3389"),
//				},
//				DomainNames: pulumi.StringArray{
//					pulumi.String("ssh_pra.example.com"),
//					pulumi.String("rdp_pra.example.com"),
//				},
//				SegmentGroupId: pulumi.Any(zpa_segment_group.This.Id),
//				ServerGroups: zpa.ApplicationSegmentPRAServerGroupArray{
//					&zpa.ApplicationSegmentPRAServerGroupArgs{
//						Ids: pulumi.StringArray{
//							zpa_server_group.This.Id,
//						},
//					},
//				},
//				CommonAppsDto: &zpa.ApplicationSegmentPRACommonAppsDtoArgs{
//					AppsConfigs: zpa.ApplicationSegmentPRACommonAppsDtoAppsConfigArray{
//						&zpa.ApplicationSegmentPRACommonAppsDtoAppsConfigArgs{
//							Name:                pulumi.String("ssh_pra"),
//							Domain:              pulumi.String("ssh_pra.example.com"),
//							ApplicationProtocol: pulumi.String("SSH"),
//							ApplicationPort:     pulumi.String("22"),
//							Enabled:             pulumi.Bool(true),
//							AppTypes: pulumi.StringArray{
//								pulumi.String("SECURE_REMOTE_ACCESS"),
//							},
//						},
//						&zpa.ApplicationSegmentPRACommonAppsDtoAppsConfigArgs{
//							Name:                pulumi.String("rdp_pra"),
//							Domain:              pulumi.String("rdp_pra.example.com"),
//							ApplicationProtocol: pulumi.String("RDP"),
//							ConnectionSecurity:  pulumi.String("ANY"),
//							ApplicationPort:     pulumi.String("3389"),
//							Enabled:             pulumi.Bool(true),
//							AppTypes: pulumi.StringArray{
//								pulumi.String("SECURE_REMOTE_ACCESS"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.
//
// # Visit
//
// Application Segment can be imported by using `<APPLICATION SEGMENT ID>` or `<APPLICATION SEGMENT NAME>` as the import ID.
//
// ```sh
// $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_id>
// ```
//
// or
//
// ```sh
// $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_name>
// ```
type ApplicationSegmentPRA struct {
	pulumi.CustomResourceState

	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType pulumi.StringOutput `pulumi:"bypassType"`
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto ApplicationSegmentPRACommonAppsDtoPtrOutput `pulumi:"commonAppsDto"`
	// (Optional)
	ConfigSpace pulumi.StringPtrOutput `pulumi:"configSpace"`
	// (Optional) Description of the application.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// List of domains and IPs.
	DomainNames pulumi.StringArrayOutput `pulumi:"domainNames"`
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt pulumi.BoolOutput `pulumi:"doubleEncrypt"`
	// Whether this application is enabled or not
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// (Optional)
	HealthCheckType pulumi.StringPtrOutput `pulumi:"healthCheckType"`
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting pulumi.StringPtrOutput `pulumi:"healthReporting"`
	// (Optional)
	IcmpAccessType pulumi.StringOutput `pulumi:"icmpAccessType"`
	// (Optional)
	IpAnchored pulumi.BoolOutput `pulumi:"ipAnchored"`
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled pulumi.BoolOutput `pulumi:"isCnameEnabled"`
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig pulumi.BoolPtrOutput `pulumi:"isIncompleteDrConfig"`
	// Name of the Privileged Remote Access
	Name pulumi.StringOutput `pulumi:"name"`
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled pulumi.BoolOutput `pulumi:"passiveHealthEnabled"`
	// List of Segment Group IDs
	SegmentGroupId   pulumi.StringOutput `pulumi:"segmentGroupId"`
	SegmentGroupName pulumi.StringOutput `pulumi:"segmentGroupName"`
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp pulumi.BoolPtrOutput `pulumi:"selectConnectorCloseToApp"`
	// List of Server Group IDs
	ServerGroups ApplicationSegmentPRAServerGroupArrayOutput `pulumi:"serverGroups"`
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive pulumi.StringOutput `pulumi:"tcpKeepAlive"`
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange ApplicationSegmentPRATcpPortRangeArrayOutput `pulumi:"tcpPortRange"`
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayOutput `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange ApplicationSegmentPRAUdpPortRangeArrayOutput `pulumi:"udpPortRange"`
	// UDP port ranges used to access the app.
	//
	// !> **WARNING:** Removing PRA applications from the `common_apps_dto.apps_config` block will cause the provider to force a replacement of the application segment.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	UdpPortRanges pulumi.StringArrayOutput `pulumi:"udpPortRanges"`
	// (Optional) Supported values: `true`, `false`
	UseInDrMode pulumi.BoolPtrOutput `pulumi:"useInDrMode"`
}

// NewApplicationSegmentPRA registers a new resource with the given unique name, arguments, and options.
func NewApplicationSegmentPRA(ctx *pulumi.Context,
	name string, args *ApplicationSegmentPRAArgs, opts ...pulumi.ResourceOption) (*ApplicationSegmentPRA, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DomainNames == nil {
		return nil, errors.New("invalid value for required argument 'DomainNames'")
	}
	if args.SegmentGroupId == nil {
		return nil, errors.New("invalid value for required argument 'SegmentGroupId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApplicationSegmentPRA
	err := ctx.RegisterResource("zpa:index/applicationSegmentPRA:ApplicationSegmentPRA", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApplicationSegmentPRA gets an existing ApplicationSegmentPRA resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApplicationSegmentPRA(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApplicationSegmentPRAState, opts ...pulumi.ResourceOption) (*ApplicationSegmentPRA, error) {
	var resource ApplicationSegmentPRA
	err := ctx.ReadResource("zpa:index/applicationSegmentPRA:ApplicationSegmentPRA", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApplicationSegmentPRA resources.
type applicationSegmentPRAState struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType *string `pulumi:"bypassType"`
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto *ApplicationSegmentPRACommonAppsDto `pulumi:"commonAppsDto"`
	// (Optional)
	ConfigSpace *string `pulumi:"configSpace"`
	// (Optional) Description of the application.
	Description *string `pulumi:"description"`
	// List of domains and IPs.
	DomainNames []string `pulumi:"domainNames"`
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt *bool `pulumi:"doubleEncrypt"`
	// Whether this application is enabled or not
	Enabled *bool `pulumi:"enabled"`
	// (Optional)
	HealthCheckType *string `pulumi:"healthCheckType"`
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting *string `pulumi:"healthReporting"`
	// (Optional)
	IcmpAccessType *string `pulumi:"icmpAccessType"`
	// (Optional)
	IpAnchored *bool `pulumi:"ipAnchored"`
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled *bool `pulumi:"isCnameEnabled"`
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig *bool `pulumi:"isIncompleteDrConfig"`
	// Name of the Privileged Remote Access
	Name *string `pulumi:"name"`
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled *bool `pulumi:"passiveHealthEnabled"`
	// List of Segment Group IDs
	SegmentGroupId   *string `pulumi:"segmentGroupId"`
	SegmentGroupName *string `pulumi:"segmentGroupName"`
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp *bool `pulumi:"selectConnectorCloseToApp"`
	// List of Server Group IDs
	ServerGroups []ApplicationSegmentPRAServerGroup `pulumi:"serverGroups"`
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive *string `pulumi:"tcpKeepAlive"`
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange []ApplicationSegmentPRATcpPortRange `pulumi:"tcpPortRange"`
	// TCP port ranges used to access the app.
	TcpPortRanges []string `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange []ApplicationSegmentPRAUdpPortRange `pulumi:"udpPortRange"`
	// UDP port ranges used to access the app.
	//
	// !> **WARNING:** Removing PRA applications from the `common_apps_dto.apps_config` block will cause the provider to force a replacement of the application segment.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	UdpPortRanges []string `pulumi:"udpPortRanges"`
	// (Optional) Supported values: `true`, `false`
	UseInDrMode *bool `pulumi:"useInDrMode"`
}

type ApplicationSegmentPRAState struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType pulumi.StringPtrInput
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto ApplicationSegmentPRACommonAppsDtoPtrInput
	// (Optional)
	ConfigSpace pulumi.StringPtrInput
	// (Optional) Description of the application.
	Description pulumi.StringPtrInput
	// List of domains and IPs.
	DomainNames pulumi.StringArrayInput
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt pulumi.BoolPtrInput
	// Whether this application is enabled or not
	Enabled pulumi.BoolPtrInput
	// (Optional)
	HealthCheckType pulumi.StringPtrInput
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting pulumi.StringPtrInput
	// (Optional)
	IcmpAccessType pulumi.StringPtrInput
	// (Optional)
	IpAnchored pulumi.BoolPtrInput
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled pulumi.BoolPtrInput
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig pulumi.BoolPtrInput
	// Name of the Privileged Remote Access
	Name pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled pulumi.BoolPtrInput
	// List of Segment Group IDs
	SegmentGroupId   pulumi.StringPtrInput
	SegmentGroupName pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp pulumi.BoolPtrInput
	// List of Server Group IDs
	ServerGroups ApplicationSegmentPRAServerGroupArrayInput
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive pulumi.StringPtrInput
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange ApplicationSegmentPRATcpPortRangeArrayInput
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayInput
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange ApplicationSegmentPRAUdpPortRangeArrayInput
	// UDP port ranges used to access the app.
	//
	// !> **WARNING:** Removing PRA applications from the `common_apps_dto.apps_config` block will cause the provider to force a replacement of the application segment.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	UdpPortRanges pulumi.StringArrayInput
	// (Optional) Supported values: `true`, `false`
	UseInDrMode pulumi.BoolPtrInput
}

func (ApplicationSegmentPRAState) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationSegmentPRAState)(nil)).Elem()
}

type applicationSegmentPRAArgs struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType *string `pulumi:"bypassType"`
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto *ApplicationSegmentPRACommonAppsDto `pulumi:"commonAppsDto"`
	// (Optional)
	ConfigSpace *string `pulumi:"configSpace"`
	// (Optional) Description of the application.
	Description *string `pulumi:"description"`
	// List of domains and IPs.
	DomainNames []string `pulumi:"domainNames"`
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt *bool `pulumi:"doubleEncrypt"`
	// Whether this application is enabled or not
	Enabled *bool `pulumi:"enabled"`
	// (Optional)
	HealthCheckType *string `pulumi:"healthCheckType"`
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting *string `pulumi:"healthReporting"`
	// (Optional)
	IcmpAccessType *string `pulumi:"icmpAccessType"`
	// (Optional)
	IpAnchored *bool `pulumi:"ipAnchored"`
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled *bool `pulumi:"isCnameEnabled"`
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig *bool `pulumi:"isIncompleteDrConfig"`
	// Name of the Privileged Remote Access
	Name *string `pulumi:"name"`
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled *bool `pulumi:"passiveHealthEnabled"`
	// List of Segment Group IDs
	SegmentGroupId   string  `pulumi:"segmentGroupId"`
	SegmentGroupName *string `pulumi:"segmentGroupName"`
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp *bool `pulumi:"selectConnectorCloseToApp"`
	// List of Server Group IDs
	ServerGroups []ApplicationSegmentPRAServerGroup `pulumi:"serverGroups"`
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive *string `pulumi:"tcpKeepAlive"`
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange []ApplicationSegmentPRATcpPortRange `pulumi:"tcpPortRange"`
	// TCP port ranges used to access the app.
	TcpPortRanges []string `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange []ApplicationSegmentPRAUdpPortRange `pulumi:"udpPortRange"`
	// UDP port ranges used to access the app.
	//
	// !> **WARNING:** Removing PRA applications from the `common_apps_dto.apps_config` block will cause the provider to force a replacement of the application segment.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	UdpPortRanges []string `pulumi:"udpPortRanges"`
	// (Optional) Supported values: `true`, `false`
	UseInDrMode *bool `pulumi:"useInDrMode"`
}

// The set of arguments for constructing a ApplicationSegmentPRA resource.
type ApplicationSegmentPRAArgs struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType pulumi.StringPtrInput
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto ApplicationSegmentPRACommonAppsDtoPtrInput
	// (Optional)
	ConfigSpace pulumi.StringPtrInput
	// (Optional) Description of the application.
	Description pulumi.StringPtrInput
	// List of domains and IPs.
	DomainNames pulumi.StringArrayInput
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt pulumi.BoolPtrInput
	// Whether this application is enabled or not
	Enabled pulumi.BoolPtrInput
	// (Optional)
	HealthCheckType pulumi.StringPtrInput
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting pulumi.StringPtrInput
	// (Optional)
	IcmpAccessType pulumi.StringPtrInput
	// (Optional)
	IpAnchored pulumi.BoolPtrInput
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled pulumi.BoolPtrInput
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig pulumi.BoolPtrInput
	// Name of the Privileged Remote Access
	Name pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled pulumi.BoolPtrInput
	// List of Segment Group IDs
	SegmentGroupId   pulumi.StringInput
	SegmentGroupName pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp pulumi.BoolPtrInput
	// List of Server Group IDs
	ServerGroups ApplicationSegmentPRAServerGroupArrayInput
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive pulumi.StringPtrInput
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange ApplicationSegmentPRATcpPortRangeArrayInput
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayInput
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange ApplicationSegmentPRAUdpPortRangeArrayInput
	// UDP port ranges used to access the app.
	//
	// !> **WARNING:** Removing PRA applications from the `common_apps_dto.apps_config` block will cause the provider to force a replacement of the application segment.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	UdpPortRanges pulumi.StringArrayInput
	// (Optional) Supported values: `true`, `false`
	UseInDrMode pulumi.BoolPtrInput
}

func (ApplicationSegmentPRAArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationSegmentPRAArgs)(nil)).Elem()
}

type ApplicationSegmentPRAInput interface {
	pulumi.Input

	ToApplicationSegmentPRAOutput() ApplicationSegmentPRAOutput
	ToApplicationSegmentPRAOutputWithContext(ctx context.Context) ApplicationSegmentPRAOutput
}

func (*ApplicationSegmentPRA) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationSegmentPRA)(nil)).Elem()
}

func (i *ApplicationSegmentPRA) ToApplicationSegmentPRAOutput() ApplicationSegmentPRAOutput {
	return i.ToApplicationSegmentPRAOutputWithContext(context.Background())
}

func (i *ApplicationSegmentPRA) ToApplicationSegmentPRAOutputWithContext(ctx context.Context) ApplicationSegmentPRAOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationSegmentPRAOutput)
}

// ApplicationSegmentPRAArrayInput is an input type that accepts ApplicationSegmentPRAArray and ApplicationSegmentPRAArrayOutput values.
// You can construct a concrete instance of `ApplicationSegmentPRAArrayInput` via:
//
//	ApplicationSegmentPRAArray{ ApplicationSegmentPRAArgs{...} }
type ApplicationSegmentPRAArrayInput interface {
	pulumi.Input

	ToApplicationSegmentPRAArrayOutput() ApplicationSegmentPRAArrayOutput
	ToApplicationSegmentPRAArrayOutputWithContext(context.Context) ApplicationSegmentPRAArrayOutput
}

type ApplicationSegmentPRAArray []ApplicationSegmentPRAInput

func (ApplicationSegmentPRAArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationSegmentPRA)(nil)).Elem()
}

func (i ApplicationSegmentPRAArray) ToApplicationSegmentPRAArrayOutput() ApplicationSegmentPRAArrayOutput {
	return i.ToApplicationSegmentPRAArrayOutputWithContext(context.Background())
}

func (i ApplicationSegmentPRAArray) ToApplicationSegmentPRAArrayOutputWithContext(ctx context.Context) ApplicationSegmentPRAArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationSegmentPRAArrayOutput)
}

// ApplicationSegmentPRAMapInput is an input type that accepts ApplicationSegmentPRAMap and ApplicationSegmentPRAMapOutput values.
// You can construct a concrete instance of `ApplicationSegmentPRAMapInput` via:
//
//	ApplicationSegmentPRAMap{ "key": ApplicationSegmentPRAArgs{...} }
type ApplicationSegmentPRAMapInput interface {
	pulumi.Input

	ToApplicationSegmentPRAMapOutput() ApplicationSegmentPRAMapOutput
	ToApplicationSegmentPRAMapOutputWithContext(context.Context) ApplicationSegmentPRAMapOutput
}

type ApplicationSegmentPRAMap map[string]ApplicationSegmentPRAInput

func (ApplicationSegmentPRAMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationSegmentPRA)(nil)).Elem()
}

func (i ApplicationSegmentPRAMap) ToApplicationSegmentPRAMapOutput() ApplicationSegmentPRAMapOutput {
	return i.ToApplicationSegmentPRAMapOutputWithContext(context.Background())
}

func (i ApplicationSegmentPRAMap) ToApplicationSegmentPRAMapOutputWithContext(ctx context.Context) ApplicationSegmentPRAMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationSegmentPRAMapOutput)
}

type ApplicationSegmentPRAOutput struct{ *pulumi.OutputState }

func (ApplicationSegmentPRAOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationSegmentPRA)(nil)).Elem()
}

func (o ApplicationSegmentPRAOutput) ToApplicationSegmentPRAOutput() ApplicationSegmentPRAOutput {
	return o
}

func (o ApplicationSegmentPRAOutput) ToApplicationSegmentPRAOutputWithContext(ctx context.Context) ApplicationSegmentPRAOutput {
	return o
}

// (Optional) Indicates whether users can bypass ZPA to access applications.
func (o ApplicationSegmentPRAOutput) BypassType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringOutput { return v.BypassType }).(pulumi.StringOutput)
}

// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
// * `apps_config:` - (Required) List of applications to be configured
func (o ApplicationSegmentPRAOutput) CommonAppsDto() ApplicationSegmentPRACommonAppsDtoPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) ApplicationSegmentPRACommonAppsDtoPtrOutput { return v.CommonAppsDto }).(ApplicationSegmentPRACommonAppsDtoPtrOutput)
}

// (Optional)
func (o ApplicationSegmentPRAOutput) ConfigSpace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringPtrOutput { return v.ConfigSpace }).(pulumi.StringPtrOutput)
}

// (Optional) Description of the application.
func (o ApplicationSegmentPRAOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// List of domains and IPs.
func (o ApplicationSegmentPRAOutput) DomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringArrayOutput { return v.DomainNames }).(pulumi.StringArrayOutput)
}

// (Optional) Whether Double Encryption is enabled or disabled for the app.
func (o ApplicationSegmentPRAOutput) DoubleEncrypt() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolOutput { return v.DoubleEncrypt }).(pulumi.BoolOutput)
}

// Whether this application is enabled or not
func (o ApplicationSegmentPRAOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// (Optional)
func (o ApplicationSegmentPRAOutput) HealthCheckType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringPtrOutput { return v.HealthCheckType }).(pulumi.StringPtrOutput)
}

// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
func (o ApplicationSegmentPRAOutput) HealthReporting() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringPtrOutput { return v.HealthReporting }).(pulumi.StringPtrOutput)
}

// (Optional)
func (o ApplicationSegmentPRAOutput) IcmpAccessType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringOutput { return v.IcmpAccessType }).(pulumi.StringOutput)
}

// (Optional)
func (o ApplicationSegmentPRAOutput) IpAnchored() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolOutput { return v.IpAnchored }).(pulumi.BoolOutput)
}

// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
func (o ApplicationSegmentPRAOutput) IsCnameEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolOutput { return v.IsCnameEnabled }).(pulumi.BoolOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentPRAOutput) IsIncompleteDrConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolPtrOutput { return v.IsIncompleteDrConfig }).(pulumi.BoolPtrOutput)
}

// Name of the Privileged Remote Access
func (o ApplicationSegmentPRAOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentPRAOutput) PassiveHealthEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolOutput { return v.PassiveHealthEnabled }).(pulumi.BoolOutput)
}

// List of Segment Group IDs
func (o ApplicationSegmentPRAOutput) SegmentGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringOutput { return v.SegmentGroupId }).(pulumi.StringOutput)
}

func (o ApplicationSegmentPRAOutput) SegmentGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringOutput { return v.SegmentGroupName }).(pulumi.StringOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentPRAOutput) SelectConnectorCloseToApp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolPtrOutput { return v.SelectConnectorCloseToApp }).(pulumi.BoolPtrOutput)
}

// List of Server Group IDs
func (o ApplicationSegmentPRAOutput) ServerGroups() ApplicationSegmentPRAServerGroupArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) ApplicationSegmentPRAServerGroupArrayOutput { return v.ServerGroups }).(ApplicationSegmentPRAServerGroupArrayOutput)
}

// (Optional) Supported values: “1“ for Enabled and “0“ for Disabled
func (o ApplicationSegmentPRAOutput) TcpKeepAlive() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringOutput { return v.TcpKeepAlive }).(pulumi.StringOutput)
}

// TCP port ranges used to access the app.
// * `from:`
// * `to:`
func (o ApplicationSegmentPRAOutput) TcpPortRange() ApplicationSegmentPRATcpPortRangeArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) ApplicationSegmentPRATcpPortRangeArrayOutput { return v.TcpPortRange }).(ApplicationSegmentPRATcpPortRangeArrayOutput)
}

// TCP port ranges used to access the app.
func (o ApplicationSegmentPRAOutput) TcpPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringArrayOutput { return v.TcpPortRanges }).(pulumi.StringArrayOutput)
}

// UDP port ranges used to access the app.
// * `from:`
// * `to:`
//
// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
func (o ApplicationSegmentPRAOutput) UdpPortRange() ApplicationSegmentPRAUdpPortRangeArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) ApplicationSegmentPRAUdpPortRangeArrayOutput { return v.UdpPortRange }).(ApplicationSegmentPRAUdpPortRangeArrayOutput)
}

// UDP port ranges used to access the app.
//
// !> **WARNING:** Removing PRA applications from the `common_apps_dto.apps_config` block will cause the provider to force a replacement of the application segment.
//
// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
func (o ApplicationSegmentPRAOutput) UdpPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.StringArrayOutput { return v.UdpPortRanges }).(pulumi.StringArrayOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentPRAOutput) UseInDrMode() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentPRA) pulumi.BoolPtrOutput { return v.UseInDrMode }).(pulumi.BoolPtrOutput)
}

type ApplicationSegmentPRAArrayOutput struct{ *pulumi.OutputState }

func (ApplicationSegmentPRAArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationSegmentPRA)(nil)).Elem()
}

func (o ApplicationSegmentPRAArrayOutput) ToApplicationSegmentPRAArrayOutput() ApplicationSegmentPRAArrayOutput {
	return o
}

func (o ApplicationSegmentPRAArrayOutput) ToApplicationSegmentPRAArrayOutputWithContext(ctx context.Context) ApplicationSegmentPRAArrayOutput {
	return o
}

func (o ApplicationSegmentPRAArrayOutput) Index(i pulumi.IntInput) ApplicationSegmentPRAOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApplicationSegmentPRA {
		return vs[0].([]*ApplicationSegmentPRA)[vs[1].(int)]
	}).(ApplicationSegmentPRAOutput)
}

type ApplicationSegmentPRAMapOutput struct{ *pulumi.OutputState }

func (ApplicationSegmentPRAMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationSegmentPRA)(nil)).Elem()
}

func (o ApplicationSegmentPRAMapOutput) ToApplicationSegmentPRAMapOutput() ApplicationSegmentPRAMapOutput {
	return o
}

func (o ApplicationSegmentPRAMapOutput) ToApplicationSegmentPRAMapOutputWithContext(ctx context.Context) ApplicationSegmentPRAMapOutput {
	return o
}

func (o ApplicationSegmentPRAMapOutput) MapIndex(k pulumi.StringInput) ApplicationSegmentPRAOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApplicationSegmentPRA {
		return vs[0].(map[string]*ApplicationSegmentPRA)[vs[1].(string)]
	}).(ApplicationSegmentPRAOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationSegmentPRAInput)(nil)).Elem(), &ApplicationSegmentPRA{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationSegmentPRAArrayInput)(nil)).Elem(), ApplicationSegmentPRAArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationSegmentPRAMapInput)(nil)).Elem(), ApplicationSegmentPRAMap{})
	pulumi.RegisterOutputType(ApplicationSegmentPRAOutput{})
	pulumi.RegisterOutputType(ApplicationSegmentPRAArrayOutput{})
	pulumi.RegisterOutputType(ApplicationSegmentPRAMapOutput{})
}
