// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zpa

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/zscaler/pulumi-zpa/sdk/go/zpa/internal"
)

// The **zpa_application_segment_inspection** resource creates an inspection application segment in the Zscaler Private Access cloud. This resource can then be referenced in an access policy inspection rule. This resource supports Inspection for both `HTTP` and `HTTPS`.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/zscaler/pulumi-zpa/sdk/go/zpa"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			jenkins, err := zpa.GetBaCertificate(ctx, &zpa.GetBaCertificateArgs{
//				Name: pulumi.StringRef("jenkins.securitygeek.io"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = zpa.NewApplicationSegmentInspection(ctx, "this", &zpa.ApplicationSegmentInspectionArgs{
//				Description:     pulumi.String("ZPA_Inspection_Example"),
//				Enabled:         pulumi.Bool(true),
//				HealthReporting: pulumi.String("ON_ACCESS"),
//				BypassType:      pulumi.String("NEVER"),
//				IsCnameEnabled:  pulumi.Bool(true),
//				TcpPortRanges: pulumi.StringArray{
//					pulumi.String("443"),
//					pulumi.String("443"),
//				},
//				DomainNames: pulumi.StringArray{
//					pulumi.String("jenkins.example.com"),
//				},
//				SegmentGroupId: pulumi.Any(zpa_segment_group.This.Id),
//				ServerGroups: zpa.ApplicationSegmentInspectionServerGroupArray{
//					&zpa.ApplicationSegmentInspectionServerGroupArgs{
//						Ids: pulumi.StringArray{
//							zpa_server_group.This.Id,
//						},
//					},
//				},
//				CommonAppsDto: &zpa.ApplicationSegmentInspectionCommonAppsDtoArgs{
//					AppsConfigs: zpa.ApplicationSegmentInspectionCommonAppsDtoAppsConfigArray{
//						&zpa.ApplicationSegmentInspectionCommonAppsDtoAppsConfigArgs{
//							Name:                pulumi.String("jenkins.example.com"),
//							Domain:              pulumi.String("jenkins.example.com"),
//							ApplicationProtocol: pulumi.String("HTTPS"),
//							ApplicationPort:     pulumi.String("443"),
//							CertificateId:       pulumi.String(jenkins.Id),
//							Enabled:             pulumi.Bool(true),
//							AppTypes: pulumi.StringArray{
//								pulumi.String("INSPECT"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.
//
// # Visit
//
// Inspection Application Segment can be imported by using `<APPLICATION SEGMENT ID>` or `<APPLICATION SEGMENT NAME>` as the import ID.
//
// ```sh
// $ pulumi import zpa:index/applicationSegmentInspection:ApplicationSegmentInspection example <application_segment_id>
// ```
//
// or
//
// ```sh
// $ pulumi import zpa:index/applicationSegmentInspection:ApplicationSegmentInspection example <application_segment_name>
// ```
type ApplicationSegmentInspection struct {
	pulumi.CustomResourceState

	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType pulumi.StringOutput `pulumi:"bypassType"`
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto ApplicationSegmentInspectionCommonAppsDtoPtrOutput `pulumi:"commonAppsDto"`
	// (Optional)
	ConfigSpace pulumi.StringPtrOutput `pulumi:"configSpace"`
	// (Optional) Description of the application.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// List of domains and IPs.
	DomainNames pulumi.StringArrayOutput `pulumi:"domainNames"`
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt pulumi.BoolOutput `pulumi:"doubleEncrypt"`
	// Whether this application is enabled or not
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// (Optional)
	HealthCheckType pulumi.StringPtrOutput `pulumi:"healthCheckType"`
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: `NONE`, `ON_ACCESS`, `CONTINUOUS`.
	HealthReporting pulumi.StringPtrOutput `pulumi:"healthReporting"`
	// (Optional)
	IcmpAccessType pulumi.StringOutput `pulumi:"icmpAccessType"`
	// (Optional)
	IpAnchored pulumi.BoolOutput `pulumi:"ipAnchored"`
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled pulumi.BoolOutput `pulumi:"isCnameEnabled"`
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig pulumi.BoolPtrOutput `pulumi:"isIncompleteDrConfig"`
	// Name of the Inspection Application Segment.
	Name pulumi.StringOutput `pulumi:"name"`
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled pulumi.BoolOutput `pulumi:"passiveHealthEnabled"`
	// List of Segment Group IDs
	SegmentGroupId   pulumi.StringOutput `pulumi:"segmentGroupId"`
	SegmentGroupName pulumi.StringOutput `pulumi:"segmentGroupName"`
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp pulumi.BoolPtrOutput `pulumi:"selectConnectorCloseToApp"`
	// List of Server Group IDs
	ServerGroups ApplicationSegmentInspectionServerGroupArrayOutput `pulumi:"serverGroups"`
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive pulumi.StringOutput `pulumi:"tcpKeepAlive"`
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange ApplicationSegmentInspectionTcpPortRangeArrayOutput `pulumi:"tcpPortRange"`
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayOutput `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange ApplicationSegmentInspectionUdpPortRangeArrayOutput `pulumi:"udpPortRange"`
	// UDP port ranges used to access the app.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	// **NOTE:** When removing TCP and/or UDP ports, parameter must be defined but set as empty due to current API behavior.
	UdpPortRanges pulumi.StringArrayOutput `pulumi:"udpPortRanges"`
	// (Optional) Supported values: `true`, `false`
	UseInDrMode pulumi.BoolPtrOutput `pulumi:"useInDrMode"`
}

// NewApplicationSegmentInspection registers a new resource with the given unique name, arguments, and options.
func NewApplicationSegmentInspection(ctx *pulumi.Context,
	name string, args *ApplicationSegmentInspectionArgs, opts ...pulumi.ResourceOption) (*ApplicationSegmentInspection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SegmentGroupId == nil {
		return nil, errors.New("invalid value for required argument 'SegmentGroupId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApplicationSegmentInspection
	err := ctx.RegisterResource("zpa:index/applicationSegmentInspection:ApplicationSegmentInspection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApplicationSegmentInspection gets an existing ApplicationSegmentInspection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApplicationSegmentInspection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApplicationSegmentInspectionState, opts ...pulumi.ResourceOption) (*ApplicationSegmentInspection, error) {
	var resource ApplicationSegmentInspection
	err := ctx.ReadResource("zpa:index/applicationSegmentInspection:ApplicationSegmentInspection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApplicationSegmentInspection resources.
type applicationSegmentInspectionState struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType *string `pulumi:"bypassType"`
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto *ApplicationSegmentInspectionCommonAppsDto `pulumi:"commonAppsDto"`
	// (Optional)
	ConfigSpace *string `pulumi:"configSpace"`
	// (Optional) Description of the application.
	Description *string `pulumi:"description"`
	// List of domains and IPs.
	DomainNames []string `pulumi:"domainNames"`
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt *bool `pulumi:"doubleEncrypt"`
	// Whether this application is enabled or not
	Enabled *bool `pulumi:"enabled"`
	// (Optional)
	HealthCheckType *string `pulumi:"healthCheckType"`
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: `NONE`, `ON_ACCESS`, `CONTINUOUS`.
	HealthReporting *string `pulumi:"healthReporting"`
	// (Optional)
	IcmpAccessType *string `pulumi:"icmpAccessType"`
	// (Optional)
	IpAnchored *bool `pulumi:"ipAnchored"`
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled *bool `pulumi:"isCnameEnabled"`
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig *bool `pulumi:"isIncompleteDrConfig"`
	// Name of the Inspection Application Segment.
	Name *string `pulumi:"name"`
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled *bool `pulumi:"passiveHealthEnabled"`
	// List of Segment Group IDs
	SegmentGroupId   *string `pulumi:"segmentGroupId"`
	SegmentGroupName *string `pulumi:"segmentGroupName"`
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp *bool `pulumi:"selectConnectorCloseToApp"`
	// List of Server Group IDs
	ServerGroups []ApplicationSegmentInspectionServerGroup `pulumi:"serverGroups"`
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive *string `pulumi:"tcpKeepAlive"`
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange []ApplicationSegmentInspectionTcpPortRange `pulumi:"tcpPortRange"`
	// TCP port ranges used to access the app.
	TcpPortRanges []string `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange []ApplicationSegmentInspectionUdpPortRange `pulumi:"udpPortRange"`
	// UDP port ranges used to access the app.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	// **NOTE:** When removing TCP and/or UDP ports, parameter must be defined but set as empty due to current API behavior.
	UdpPortRanges []string `pulumi:"udpPortRanges"`
	// (Optional) Supported values: `true`, `false`
	UseInDrMode *bool `pulumi:"useInDrMode"`
}

type ApplicationSegmentInspectionState struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType pulumi.StringPtrInput
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto ApplicationSegmentInspectionCommonAppsDtoPtrInput
	// (Optional)
	ConfigSpace pulumi.StringPtrInput
	// (Optional) Description of the application.
	Description pulumi.StringPtrInput
	// List of domains and IPs.
	DomainNames pulumi.StringArrayInput
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt pulumi.BoolPtrInput
	// Whether this application is enabled or not
	Enabled pulumi.BoolPtrInput
	// (Optional)
	HealthCheckType pulumi.StringPtrInput
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: `NONE`, `ON_ACCESS`, `CONTINUOUS`.
	HealthReporting pulumi.StringPtrInput
	// (Optional)
	IcmpAccessType pulumi.StringPtrInput
	// (Optional)
	IpAnchored pulumi.BoolPtrInput
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled pulumi.BoolPtrInput
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig pulumi.BoolPtrInput
	// Name of the Inspection Application Segment.
	Name pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled pulumi.BoolPtrInput
	// List of Segment Group IDs
	SegmentGroupId   pulumi.StringPtrInput
	SegmentGroupName pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp pulumi.BoolPtrInput
	// List of Server Group IDs
	ServerGroups ApplicationSegmentInspectionServerGroupArrayInput
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive pulumi.StringPtrInput
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange ApplicationSegmentInspectionTcpPortRangeArrayInput
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayInput
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange ApplicationSegmentInspectionUdpPortRangeArrayInput
	// UDP port ranges used to access the app.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	// **NOTE:** When removing TCP and/or UDP ports, parameter must be defined but set as empty due to current API behavior.
	UdpPortRanges pulumi.StringArrayInput
	// (Optional) Supported values: `true`, `false`
	UseInDrMode pulumi.BoolPtrInput
}

func (ApplicationSegmentInspectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationSegmentInspectionState)(nil)).Elem()
}

type applicationSegmentInspectionArgs struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType *string `pulumi:"bypassType"`
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto *ApplicationSegmentInspectionCommonAppsDto `pulumi:"commonAppsDto"`
	// (Optional)
	ConfigSpace *string `pulumi:"configSpace"`
	// (Optional) Description of the application.
	Description *string `pulumi:"description"`
	// List of domains and IPs.
	DomainNames []string `pulumi:"domainNames"`
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt *bool `pulumi:"doubleEncrypt"`
	// Whether this application is enabled or not
	Enabled *bool `pulumi:"enabled"`
	// (Optional)
	HealthCheckType *string `pulumi:"healthCheckType"`
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: `NONE`, `ON_ACCESS`, `CONTINUOUS`.
	HealthReporting *string `pulumi:"healthReporting"`
	// (Optional)
	IcmpAccessType *string `pulumi:"icmpAccessType"`
	// (Optional)
	IpAnchored *bool `pulumi:"ipAnchored"`
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled *bool `pulumi:"isCnameEnabled"`
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig *bool `pulumi:"isIncompleteDrConfig"`
	// Name of the Inspection Application Segment.
	Name *string `pulumi:"name"`
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled *bool `pulumi:"passiveHealthEnabled"`
	// List of Segment Group IDs
	SegmentGroupId   string  `pulumi:"segmentGroupId"`
	SegmentGroupName *string `pulumi:"segmentGroupName"`
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp *bool `pulumi:"selectConnectorCloseToApp"`
	// List of Server Group IDs
	ServerGroups []ApplicationSegmentInspectionServerGroup `pulumi:"serverGroups"`
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive *string `pulumi:"tcpKeepAlive"`
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange []ApplicationSegmentInspectionTcpPortRange `pulumi:"tcpPortRange"`
	// TCP port ranges used to access the app.
	TcpPortRanges []string `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange []ApplicationSegmentInspectionUdpPortRange `pulumi:"udpPortRange"`
	// UDP port ranges used to access the app.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	// **NOTE:** When removing TCP and/or UDP ports, parameter must be defined but set as empty due to current API behavior.
	UdpPortRanges []string `pulumi:"udpPortRanges"`
	// (Optional) Supported values: `true`, `false`
	UseInDrMode *bool `pulumi:"useInDrMode"`
}

// The set of arguments for constructing a ApplicationSegmentInspection resource.
type ApplicationSegmentInspectionArgs struct {
	// (Optional) Indicates whether users can bypass ZPA to access applications.
	BypassType pulumi.StringPtrInput
	// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
	// * `apps_config:` - (Required) List of applications to be configured
	CommonAppsDto ApplicationSegmentInspectionCommonAppsDtoPtrInput
	// (Optional)
	ConfigSpace pulumi.StringPtrInput
	// (Optional) Description of the application.
	Description pulumi.StringPtrInput
	// List of domains and IPs.
	DomainNames pulumi.StringArrayInput
	// (Optional) Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt pulumi.BoolPtrInput
	// Whether this application is enabled or not
	Enabled pulumi.BoolPtrInput
	// (Optional)
	HealthCheckType pulumi.StringPtrInput
	// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: `NONE`, `ON_ACCESS`, `CONTINUOUS`.
	HealthReporting pulumi.StringPtrInput
	// (Optional)
	IcmpAccessType pulumi.StringPtrInput
	// (Optional)
	IpAnchored pulumi.BoolPtrInput
	// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
	IsCnameEnabled pulumi.BoolPtrInput
	// (Optional) Supported values: `true`, `false`
	IsIncompleteDrConfig pulumi.BoolPtrInput
	// Name of the Inspection Application Segment.
	Name pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	PassiveHealthEnabled pulumi.BoolPtrInput
	// List of Segment Group IDs
	SegmentGroupId   pulumi.StringInput
	SegmentGroupName pulumi.StringPtrInput
	// (Optional) Supported values: `true`, `false`
	SelectConnectorCloseToApp pulumi.BoolPtrInput
	// List of Server Group IDs
	ServerGroups ApplicationSegmentInspectionServerGroupArrayInput
	// (Optional) Supported values: ``1`` for Enabled and ``0`` for Disabled
	TcpKeepAlive pulumi.StringPtrInput
	// TCP port ranges used to access the app.
	// * `from:`
	// * `to:`
	TcpPortRange ApplicationSegmentInspectionTcpPortRangeArrayInput
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayInput
	// UDP port ranges used to access the app.
	// * `from:`
	// * `to:`
	//
	// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
	UdpPortRange ApplicationSegmentInspectionUdpPortRangeArrayInput
	// UDP port ranges used to access the app.
	//
	// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
	// **NOTE:** When removing TCP and/or UDP ports, parameter must be defined but set as empty due to current API behavior.
	UdpPortRanges pulumi.StringArrayInput
	// (Optional) Supported values: `true`, `false`
	UseInDrMode pulumi.BoolPtrInput
}

func (ApplicationSegmentInspectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*applicationSegmentInspectionArgs)(nil)).Elem()
}

type ApplicationSegmentInspectionInput interface {
	pulumi.Input

	ToApplicationSegmentInspectionOutput() ApplicationSegmentInspectionOutput
	ToApplicationSegmentInspectionOutputWithContext(ctx context.Context) ApplicationSegmentInspectionOutput
}

func (*ApplicationSegmentInspection) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationSegmentInspection)(nil)).Elem()
}

func (i *ApplicationSegmentInspection) ToApplicationSegmentInspectionOutput() ApplicationSegmentInspectionOutput {
	return i.ToApplicationSegmentInspectionOutputWithContext(context.Background())
}

func (i *ApplicationSegmentInspection) ToApplicationSegmentInspectionOutputWithContext(ctx context.Context) ApplicationSegmentInspectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationSegmentInspectionOutput)
}

// ApplicationSegmentInspectionArrayInput is an input type that accepts ApplicationSegmentInspectionArray and ApplicationSegmentInspectionArrayOutput values.
// You can construct a concrete instance of `ApplicationSegmentInspectionArrayInput` via:
//
//	ApplicationSegmentInspectionArray{ ApplicationSegmentInspectionArgs{...} }
type ApplicationSegmentInspectionArrayInput interface {
	pulumi.Input

	ToApplicationSegmentInspectionArrayOutput() ApplicationSegmentInspectionArrayOutput
	ToApplicationSegmentInspectionArrayOutputWithContext(context.Context) ApplicationSegmentInspectionArrayOutput
}

type ApplicationSegmentInspectionArray []ApplicationSegmentInspectionInput

func (ApplicationSegmentInspectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationSegmentInspection)(nil)).Elem()
}

func (i ApplicationSegmentInspectionArray) ToApplicationSegmentInspectionArrayOutput() ApplicationSegmentInspectionArrayOutput {
	return i.ToApplicationSegmentInspectionArrayOutputWithContext(context.Background())
}

func (i ApplicationSegmentInspectionArray) ToApplicationSegmentInspectionArrayOutputWithContext(ctx context.Context) ApplicationSegmentInspectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationSegmentInspectionArrayOutput)
}

// ApplicationSegmentInspectionMapInput is an input type that accepts ApplicationSegmentInspectionMap and ApplicationSegmentInspectionMapOutput values.
// You can construct a concrete instance of `ApplicationSegmentInspectionMapInput` via:
//
//	ApplicationSegmentInspectionMap{ "key": ApplicationSegmentInspectionArgs{...} }
type ApplicationSegmentInspectionMapInput interface {
	pulumi.Input

	ToApplicationSegmentInspectionMapOutput() ApplicationSegmentInspectionMapOutput
	ToApplicationSegmentInspectionMapOutputWithContext(context.Context) ApplicationSegmentInspectionMapOutput
}

type ApplicationSegmentInspectionMap map[string]ApplicationSegmentInspectionInput

func (ApplicationSegmentInspectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationSegmentInspection)(nil)).Elem()
}

func (i ApplicationSegmentInspectionMap) ToApplicationSegmentInspectionMapOutput() ApplicationSegmentInspectionMapOutput {
	return i.ToApplicationSegmentInspectionMapOutputWithContext(context.Background())
}

func (i ApplicationSegmentInspectionMap) ToApplicationSegmentInspectionMapOutputWithContext(ctx context.Context) ApplicationSegmentInspectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationSegmentInspectionMapOutput)
}

type ApplicationSegmentInspectionOutput struct{ *pulumi.OutputState }

func (ApplicationSegmentInspectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationSegmentInspection)(nil)).Elem()
}

func (o ApplicationSegmentInspectionOutput) ToApplicationSegmentInspectionOutput() ApplicationSegmentInspectionOutput {
	return o
}

func (o ApplicationSegmentInspectionOutput) ToApplicationSegmentInspectionOutputWithContext(ctx context.Context) ApplicationSegmentInspectionOutput {
	return o
}

// (Optional) Indicates whether users can bypass ZPA to access applications.
func (o ApplicationSegmentInspectionOutput) BypassType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringOutput { return v.BypassType }).(pulumi.StringOutput)
}

// List of applications (e.g., Inspection, Browser Access or Privileged Remote Access)
// * `apps_config:` - (Required) List of applications to be configured
func (o ApplicationSegmentInspectionOutput) CommonAppsDto() ApplicationSegmentInspectionCommonAppsDtoPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) ApplicationSegmentInspectionCommonAppsDtoPtrOutput {
		return v.CommonAppsDto
	}).(ApplicationSegmentInspectionCommonAppsDtoPtrOutput)
}

// (Optional)
func (o ApplicationSegmentInspectionOutput) ConfigSpace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringPtrOutput { return v.ConfigSpace }).(pulumi.StringPtrOutput)
}

// (Optional) Description of the application.
func (o ApplicationSegmentInspectionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// List of domains and IPs.
func (o ApplicationSegmentInspectionOutput) DomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringArrayOutput { return v.DomainNames }).(pulumi.StringArrayOutput)
}

// (Optional) Whether Double Encryption is enabled or disabled for the app.
func (o ApplicationSegmentInspectionOutput) DoubleEncrypt() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolOutput { return v.DoubleEncrypt }).(pulumi.BoolOutput)
}

// Whether this application is enabled or not
func (o ApplicationSegmentInspectionOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// (Optional)
func (o ApplicationSegmentInspectionOutput) HealthCheckType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringPtrOutput { return v.HealthCheckType }).(pulumi.StringPtrOutput)
}

// (Optional) Whether health reporting for the app is Continuous or On Access. Supported values: `NONE`, `ON_ACCESS`, `CONTINUOUS`.
func (o ApplicationSegmentInspectionOutput) HealthReporting() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringPtrOutput { return v.HealthReporting }).(pulumi.StringPtrOutput)
}

// (Optional)
func (o ApplicationSegmentInspectionOutput) IcmpAccessType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringOutput { return v.IcmpAccessType }).(pulumi.StringOutput)
}

// (Optional)
func (o ApplicationSegmentInspectionOutput) IpAnchored() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolOutput { return v.IpAnchored }).(pulumi.BoolOutput)
}

// (Optional) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
func (o ApplicationSegmentInspectionOutput) IsCnameEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolOutput { return v.IsCnameEnabled }).(pulumi.BoolOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentInspectionOutput) IsIncompleteDrConfig() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolPtrOutput { return v.IsIncompleteDrConfig }).(pulumi.BoolPtrOutput)
}

// Name of the Inspection Application Segment.
func (o ApplicationSegmentInspectionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentInspectionOutput) PassiveHealthEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolOutput { return v.PassiveHealthEnabled }).(pulumi.BoolOutput)
}

// List of Segment Group IDs
func (o ApplicationSegmentInspectionOutput) SegmentGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringOutput { return v.SegmentGroupId }).(pulumi.StringOutput)
}

func (o ApplicationSegmentInspectionOutput) SegmentGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringOutput { return v.SegmentGroupName }).(pulumi.StringOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentInspectionOutput) SelectConnectorCloseToApp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolPtrOutput { return v.SelectConnectorCloseToApp }).(pulumi.BoolPtrOutput)
}

// List of Server Group IDs
func (o ApplicationSegmentInspectionOutput) ServerGroups() ApplicationSegmentInspectionServerGroupArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) ApplicationSegmentInspectionServerGroupArrayOutput {
		return v.ServerGroups
	}).(ApplicationSegmentInspectionServerGroupArrayOutput)
}

// (Optional) Supported values: “1“ for Enabled and “0“ for Disabled
func (o ApplicationSegmentInspectionOutput) TcpKeepAlive() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringOutput { return v.TcpKeepAlive }).(pulumi.StringOutput)
}

// TCP port ranges used to access the app.
// * `from:`
// * `to:`
func (o ApplicationSegmentInspectionOutput) TcpPortRange() ApplicationSegmentInspectionTcpPortRangeArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) ApplicationSegmentInspectionTcpPortRangeArrayOutput {
		return v.TcpPortRange
	}).(ApplicationSegmentInspectionTcpPortRangeArrayOutput)
}

// TCP port ranges used to access the app.
func (o ApplicationSegmentInspectionOutput) TcpPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringArrayOutput { return v.TcpPortRanges }).(pulumi.StringArrayOutput)
}

// UDP port ranges used to access the app.
// * `from:`
// * `to:`
//
// > **NOTE:** Application segments must have unique ports and cannot have overlapping domain names using the same tcp/udp ports across multiple application segments.
func (o ApplicationSegmentInspectionOutput) UdpPortRange() ApplicationSegmentInspectionUdpPortRangeArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) ApplicationSegmentInspectionUdpPortRangeArrayOutput {
		return v.UdpPortRange
	}).(ApplicationSegmentInspectionUdpPortRangeArrayOutput)
}

// UDP port ranges used to access the app.
//
// > **NOTE:**  TCP and UDP ports can also be defined using the following model:
// **NOTE:** When removing TCP and/or UDP ports, parameter must be defined but set as empty due to current API behavior.
func (o ApplicationSegmentInspectionOutput) UdpPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.StringArrayOutput { return v.UdpPortRanges }).(pulumi.StringArrayOutput)
}

// (Optional) Supported values: `true`, `false`
func (o ApplicationSegmentInspectionOutput) UseInDrMode() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ApplicationSegmentInspection) pulumi.BoolPtrOutput { return v.UseInDrMode }).(pulumi.BoolPtrOutput)
}

type ApplicationSegmentInspectionArrayOutput struct{ *pulumi.OutputState }

func (ApplicationSegmentInspectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplicationSegmentInspection)(nil)).Elem()
}

func (o ApplicationSegmentInspectionArrayOutput) ToApplicationSegmentInspectionArrayOutput() ApplicationSegmentInspectionArrayOutput {
	return o
}

func (o ApplicationSegmentInspectionArrayOutput) ToApplicationSegmentInspectionArrayOutputWithContext(ctx context.Context) ApplicationSegmentInspectionArrayOutput {
	return o
}

func (o ApplicationSegmentInspectionArrayOutput) Index(i pulumi.IntInput) ApplicationSegmentInspectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApplicationSegmentInspection {
		return vs[0].([]*ApplicationSegmentInspection)[vs[1].(int)]
	}).(ApplicationSegmentInspectionOutput)
}

type ApplicationSegmentInspectionMapOutput struct{ *pulumi.OutputState }

func (ApplicationSegmentInspectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplicationSegmentInspection)(nil)).Elem()
}

func (o ApplicationSegmentInspectionMapOutput) ToApplicationSegmentInspectionMapOutput() ApplicationSegmentInspectionMapOutput {
	return o
}

func (o ApplicationSegmentInspectionMapOutput) ToApplicationSegmentInspectionMapOutputWithContext(ctx context.Context) ApplicationSegmentInspectionMapOutput {
	return o
}

func (o ApplicationSegmentInspectionMapOutput) MapIndex(k pulumi.StringInput) ApplicationSegmentInspectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApplicationSegmentInspection {
		return vs[0].(map[string]*ApplicationSegmentInspection)[vs[1].(string)]
	}).(ApplicationSegmentInspectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationSegmentInspectionInput)(nil)).Elem(), &ApplicationSegmentInspection{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationSegmentInspectionArrayInput)(nil)).Elem(), ApplicationSegmentInspectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationSegmentInspectionMapInput)(nil)).Elem(), ApplicationSegmentInspectionMap{})
	pulumi.RegisterOutputType(ApplicationSegmentInspectionOutput{})
	pulumi.RegisterOutputType(ApplicationSegmentInspectionArrayOutput{})
	pulumi.RegisterOutputType(ApplicationSegmentInspectionMapOutput{})
}
