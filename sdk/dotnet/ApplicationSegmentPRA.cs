// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Zscaler.Zpa
{
    /// <summary>
    /// * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
    /// * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)
    /// 
    /// The **zpa_application_segment_pra** resource creates an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Zpa = Zscaler.Zpa;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Zpa.ApplicationSegmentPRA("this", new()
    ///     {
    ///         Description = "PRA_Example",
    ///         Enabled = true,
    ///         HealthReporting = "ON_ACCESS",
    ///         BypassType = "NEVER",
    ///         IsCnameEnabled = true,
    ///         TcpPortRanges = new[]
    ///         {
    ///             "22",
    ///             "22",
    ///             "3389",
    ///             "3389",
    ///         },
    ///         DomainNames = new[]
    ///         {
    ///             "ssh_pra.example.com",
    ///             "rdp_pra.example.com",
    ///         },
    ///         SegmentGroupId = zpa_segment_group.This.Id,
    ///         ServerGroups = new[]
    ///         {
    ///             new Zpa.Inputs.ApplicationSegmentPRAServerGroupArgs
    ///             {
    ///                 Ids = new[]
    ///                 {
    ///                     zpa_server_group.This.Id,
    ///                 },
    ///             },
    ///         },
    ///         CommonAppsDto = new Zpa.Inputs.ApplicationSegmentPRACommonAppsDtoArgs
    ///         {
    ///             AppsConfigs = new[]
    ///             {
    ///                 new Zpa.Inputs.ApplicationSegmentPRACommonAppsDtoAppsConfigArgs
    ///                 {
    ///                     Domain = "ssh_pra.example.com",
    ///                     ApplicationProtocol = "SSH",
    ///                     ApplicationPort = "22",
    ///                     Enabled = true,
    ///                     AppTypes = new[]
    ///                     {
    ///                         "SECURE_REMOTE_ACCESS",
    ///                     },
    ///                 },
    ///                 new Zpa.Inputs.ApplicationSegmentPRACommonAppsDtoAppsConfigArgs
    ///                 {
    ///                     Domain = "rdp_pra.example.com",
    ///                     ApplicationProtocol = "RDP",
    ///                     ConnectionSecurity = "ANY",
    ///                     ApplicationPort = "3389",
    ///                     Enabled = true,
    ///                     AppTypes = new[]
    ///                     {
    ///                         "SECURE_REMOTE_ACCESS",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.
    /// 
    /// Visit
    /// 
    /// Application Segment can be imported by using `&lt;APPLICATION SEGMENT ID&gt;` or `&lt;APPLICATION SEGMENT NAME&gt;` as the import ID.
    /// 
    /// ```sh
    /// $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example &lt;application_segment_id&gt;
    /// ```
    /// 
    /// or
    /// 
    /// ```sh
    /// $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example &lt;application_segment_name&gt;
    /// ```
    /// </summary>
    [ZpaResourceType("zpa:index/applicationSegmentPRA:ApplicationSegmentPRA")]
    public partial class ApplicationSegmentPRA : global::Pulumi.CustomResource
    {
        [Output("bypassOnReauth")]
        public Output<bool> BypassOnReauth { get; private set; } = null!;

        /// <summary>
        /// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
        /// The value NEVER indicates the use of the client forwarding policy.
        /// </summary>
        [Output("bypassType")]
        public Output<string> BypassType { get; private set; } = null!;

        [Output("commonAppsDto")]
        public Output<Outputs.ApplicationSegmentPRACommonAppsDto> CommonAppsDto { get; private set; } = null!;

        [Output("configSpace")]
        public Output<string?> ConfigSpace { get; private set; } = null!;

        /// <summary>
        /// Description of the application.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// List of domains and IPs.
        /// </summary>
        [Output("domainNames")]
        public Output<ImmutableArray<string>> DomainNames { get; private set; } = null!;

        /// <summary>
        /// Whether Double Encryption is enabled or disabled for the app.
        /// </summary>
        [Output("doubleEncrypt")]
        public Output<bool> DoubleEncrypt { get; private set; } = null!;

        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        [Output("fqdnDnsCheck")]
        public Output<bool?> FqdnDnsCheck { get; private set; } = null!;

        [Output("healthCheckType")]
        public Output<string?> HealthCheckType { get; private set; } = null!;

        /// <summary>
        /// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        /// </summary>
        [Output("healthReporting")]
        public Output<string?> HealthReporting { get; private set; } = null!;

        [Output("icmpAccessType")]
        public Output<string> IcmpAccessType { get; private set; } = null!;

        [Output("ipAnchored")]
        public Output<bool?> IpAnchored { get; private set; } = null!;

        /// <summary>
        /// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
        /// connectors.
        /// </summary>
        [Output("isCnameEnabled")]
        public Output<bool> IsCnameEnabled { get; private set; } = null!;

        [Output("isIncompleteDrConfig")]
        public Output<bool> IsIncompleteDrConfig { get; private set; } = null!;

        [Output("microtenantId")]
        public Output<string> MicrotenantId { get; private set; } = null!;

        /// <summary>
        /// Name of the application.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("passiveHealthEnabled")]
        public Output<bool> PassiveHealthEnabled { get; private set; } = null!;

        [Output("segmentGroupId")]
        public Output<string> SegmentGroupId { get; private set; } = null!;

        [Output("selectConnectorCloseToApp")]
        public Output<bool?> SelectConnectorCloseToApp { get; private set; } = null!;

        [Output("serverGroups")]
        public Output<ImmutableArray<Outputs.ApplicationSegmentPRAServerGroup>> ServerGroups { get; private set; } = null!;

        [Output("tcpKeepAlive")]
        public Output<string> TcpKeepAlive { get; private set; } = null!;

        /// <summary>
        /// tcp port range
        /// </summary>
        [Output("tcpPortRange")]
        public Output<ImmutableArray<Outputs.ApplicationSegmentPRATcpPortRange>> TcpPortRange { get; private set; } = null!;

        /// <summary>
        /// TCP port ranges used to access the app.
        /// </summary>
        [Output("tcpPortRanges")]
        public Output<ImmutableArray<string>> TcpPortRanges { get; private set; } = null!;

        /// <summary>
        /// udp port range
        /// </summary>
        [Output("udpPortRange")]
        public Output<ImmutableArray<Outputs.ApplicationSegmentPRAUdpPortRange>> UdpPortRange { get; private set; } = null!;

        /// <summary>
        /// UDP port ranges used to access the app.
        /// </summary>
        [Output("udpPortRanges")]
        public Output<ImmutableArray<string>> UdpPortRanges { get; private set; } = null!;

        [Output("useInDrMode")]
        public Output<bool> UseInDrMode { get; private set; } = null!;


        /// <summary>
        /// Create a ApplicationSegmentPRA resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ApplicationSegmentPRA(string name, ApplicationSegmentPRAArgs args, CustomResourceOptions? options = null)
            : base("zpa:index/applicationSegmentPRA:ApplicationSegmentPRA", name, args ?? new ApplicationSegmentPRAArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ApplicationSegmentPRA(string name, Input<string> id, ApplicationSegmentPRAState? state = null, CustomResourceOptions? options = null)
            : base("zpa:index/applicationSegmentPRA:ApplicationSegmentPRA", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/zscaler",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ApplicationSegmentPRA resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ApplicationSegmentPRA Get(string name, Input<string> id, ApplicationSegmentPRAState? state = null, CustomResourceOptions? options = null)
        {
            return new ApplicationSegmentPRA(name, id, state, options);
        }
    }

    public sealed class ApplicationSegmentPRAArgs : global::Pulumi.ResourceArgs
    {
        [Input("bypassOnReauth")]
        public Input<bool>? BypassOnReauth { get; set; }

        /// <summary>
        /// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
        /// The value NEVER indicates the use of the client forwarding policy.
        /// </summary>
        [Input("bypassType")]
        public Input<string>? BypassType { get; set; }

        [Input("commonAppsDto")]
        public Input<Inputs.ApplicationSegmentPRACommonAppsDtoArgs>? CommonAppsDto { get; set; }

        [Input("configSpace")]
        public Input<string>? ConfigSpace { get; set; }

        /// <summary>
        /// Description of the application.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("domainNames", required: true)]
        private InputList<string>? _domainNames;

        /// <summary>
        /// List of domains and IPs.
        /// </summary>
        public InputList<string> DomainNames
        {
            get => _domainNames ?? (_domainNames = new InputList<string>());
            set => _domainNames = value;
        }

        /// <summary>
        /// Whether Double Encryption is enabled or disabled for the app.
        /// </summary>
        [Input("doubleEncrypt")]
        public Input<bool>? DoubleEncrypt { get; set; }

        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        [Input("fqdnDnsCheck")]
        public Input<bool>? FqdnDnsCheck { get; set; }

        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        /// <summary>
        /// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        /// </summary>
        [Input("healthReporting")]
        public Input<string>? HealthReporting { get; set; }

        [Input("icmpAccessType")]
        public Input<string>? IcmpAccessType { get; set; }

        [Input("ipAnchored")]
        public Input<bool>? IpAnchored { get; set; }

        /// <summary>
        /// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
        /// connectors.
        /// </summary>
        [Input("isCnameEnabled")]
        public Input<bool>? IsCnameEnabled { get; set; }

        [Input("isIncompleteDrConfig")]
        public Input<bool>? IsIncompleteDrConfig { get; set; }

        [Input("microtenantId")]
        public Input<string>? MicrotenantId { get; set; }

        /// <summary>
        /// Name of the application.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("passiveHealthEnabled")]
        public Input<bool>? PassiveHealthEnabled { get; set; }

        [Input("segmentGroupId", required: true)]
        public Input<string> SegmentGroupId { get; set; } = null!;

        [Input("selectConnectorCloseToApp")]
        public Input<bool>? SelectConnectorCloseToApp { get; set; }

        [Input("serverGroups")]
        private InputList<Inputs.ApplicationSegmentPRAServerGroupArgs>? _serverGroups;
        public InputList<Inputs.ApplicationSegmentPRAServerGroupArgs> ServerGroups
        {
            get => _serverGroups ?? (_serverGroups = new InputList<Inputs.ApplicationSegmentPRAServerGroupArgs>());
            set => _serverGroups = value;
        }

        [Input("tcpKeepAlive")]
        public Input<string>? TcpKeepAlive { get; set; }

        [Input("tcpPortRange")]
        private InputList<Inputs.ApplicationSegmentPRATcpPortRangeArgs>? _tcpPortRange;

        /// <summary>
        /// tcp port range
        /// </summary>
        public InputList<Inputs.ApplicationSegmentPRATcpPortRangeArgs> TcpPortRange
        {
            get => _tcpPortRange ?? (_tcpPortRange = new InputList<Inputs.ApplicationSegmentPRATcpPortRangeArgs>());
            set => _tcpPortRange = value;
        }

        [Input("tcpPortRanges")]
        private InputList<string>? _tcpPortRanges;

        /// <summary>
        /// TCP port ranges used to access the app.
        /// </summary>
        public InputList<string> TcpPortRanges
        {
            get => _tcpPortRanges ?? (_tcpPortRanges = new InputList<string>());
            set => _tcpPortRanges = value;
        }

        [Input("udpPortRange")]
        private InputList<Inputs.ApplicationSegmentPRAUdpPortRangeArgs>? _udpPortRange;

        /// <summary>
        /// udp port range
        /// </summary>
        public InputList<Inputs.ApplicationSegmentPRAUdpPortRangeArgs> UdpPortRange
        {
            get => _udpPortRange ?? (_udpPortRange = new InputList<Inputs.ApplicationSegmentPRAUdpPortRangeArgs>());
            set => _udpPortRange = value;
        }

        [Input("udpPortRanges")]
        private InputList<string>? _udpPortRanges;

        /// <summary>
        /// UDP port ranges used to access the app.
        /// </summary>
        public InputList<string> UdpPortRanges
        {
            get => _udpPortRanges ?? (_udpPortRanges = new InputList<string>());
            set => _udpPortRanges = value;
        }

        [Input("useInDrMode")]
        public Input<bool>? UseInDrMode { get; set; }

        public ApplicationSegmentPRAArgs()
        {
        }
        public static new ApplicationSegmentPRAArgs Empty => new ApplicationSegmentPRAArgs();
    }

    public sealed class ApplicationSegmentPRAState : global::Pulumi.ResourceArgs
    {
        [Input("bypassOnReauth")]
        public Input<bool>? BypassOnReauth { get; set; }

        /// <summary>
        /// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
        /// The value NEVER indicates the use of the client forwarding policy.
        /// </summary>
        [Input("bypassType")]
        public Input<string>? BypassType { get; set; }

        [Input("commonAppsDto")]
        public Input<Inputs.ApplicationSegmentPRACommonAppsDtoGetArgs>? CommonAppsDto { get; set; }

        [Input("configSpace")]
        public Input<string>? ConfigSpace { get; set; }

        /// <summary>
        /// Description of the application.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("domainNames")]
        private InputList<string>? _domainNames;

        /// <summary>
        /// List of domains and IPs.
        /// </summary>
        public InputList<string> DomainNames
        {
            get => _domainNames ?? (_domainNames = new InputList<string>());
            set => _domainNames = value;
        }

        /// <summary>
        /// Whether Double Encryption is enabled or disabled for the app.
        /// </summary>
        [Input("doubleEncrypt")]
        public Input<bool>? DoubleEncrypt { get; set; }

        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        [Input("fqdnDnsCheck")]
        public Input<bool>? FqdnDnsCheck { get; set; }

        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        /// <summary>
        /// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        /// </summary>
        [Input("healthReporting")]
        public Input<string>? HealthReporting { get; set; }

        [Input("icmpAccessType")]
        public Input<string>? IcmpAccessType { get; set; }

        [Input("ipAnchored")]
        public Input<bool>? IpAnchored { get; set; }

        /// <summary>
        /// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
        /// connectors.
        /// </summary>
        [Input("isCnameEnabled")]
        public Input<bool>? IsCnameEnabled { get; set; }

        [Input("isIncompleteDrConfig")]
        public Input<bool>? IsIncompleteDrConfig { get; set; }

        [Input("microtenantId")]
        public Input<string>? MicrotenantId { get; set; }

        /// <summary>
        /// Name of the application.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("passiveHealthEnabled")]
        public Input<bool>? PassiveHealthEnabled { get; set; }

        [Input("segmentGroupId")]
        public Input<string>? SegmentGroupId { get; set; }

        [Input("selectConnectorCloseToApp")]
        public Input<bool>? SelectConnectorCloseToApp { get; set; }

        [Input("serverGroups")]
        private InputList<Inputs.ApplicationSegmentPRAServerGroupGetArgs>? _serverGroups;
        public InputList<Inputs.ApplicationSegmentPRAServerGroupGetArgs> ServerGroups
        {
            get => _serverGroups ?? (_serverGroups = new InputList<Inputs.ApplicationSegmentPRAServerGroupGetArgs>());
            set => _serverGroups = value;
        }

        [Input("tcpKeepAlive")]
        public Input<string>? TcpKeepAlive { get; set; }

        [Input("tcpPortRange")]
        private InputList<Inputs.ApplicationSegmentPRATcpPortRangeGetArgs>? _tcpPortRange;

        /// <summary>
        /// tcp port range
        /// </summary>
        public InputList<Inputs.ApplicationSegmentPRATcpPortRangeGetArgs> TcpPortRange
        {
            get => _tcpPortRange ?? (_tcpPortRange = new InputList<Inputs.ApplicationSegmentPRATcpPortRangeGetArgs>());
            set => _tcpPortRange = value;
        }

        [Input("tcpPortRanges")]
        private InputList<string>? _tcpPortRanges;

        /// <summary>
        /// TCP port ranges used to access the app.
        /// </summary>
        public InputList<string> TcpPortRanges
        {
            get => _tcpPortRanges ?? (_tcpPortRanges = new InputList<string>());
            set => _tcpPortRanges = value;
        }

        [Input("udpPortRange")]
        private InputList<Inputs.ApplicationSegmentPRAUdpPortRangeGetArgs>? _udpPortRange;

        /// <summary>
        /// udp port range
        /// </summary>
        public InputList<Inputs.ApplicationSegmentPRAUdpPortRangeGetArgs> UdpPortRange
        {
            get => _udpPortRange ?? (_udpPortRange = new InputList<Inputs.ApplicationSegmentPRAUdpPortRangeGetArgs>());
            set => _udpPortRange = value;
        }

        [Input("udpPortRanges")]
        private InputList<string>? _udpPortRanges;

        /// <summary>
        /// UDP port ranges used to access the app.
        /// </summary>
        public InputList<string> UdpPortRanges
        {
            get => _udpPortRanges ?? (_udpPortRanges = new InputList<string>());
            set => _udpPortRanges = value;
        }

        [Input("useInDrMode")]
        public Input<bool>? UseInDrMode { get; set; }

        public ApplicationSegmentPRAState()
        {
        }
        public static new ApplicationSegmentPRAState Empty => new ApplicationSegmentPRAState();
    }
}
