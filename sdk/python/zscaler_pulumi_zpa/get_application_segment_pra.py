# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetApplicationSegmentPRAResult',
    'AwaitableGetApplicationSegmentPRAResult',
    'get_application_segment_pra',
    'get_application_segment_pra_output',
]

@pulumi.output_type
class GetApplicationSegmentPRAResult:
    """
    A collection of values returned by getApplicationSegmentPRA.
    """
    def __init__(__self__, bypass_type=None, config_space=None, description=None, domain_names=None, double_encrypt=None, enabled=None, health_check_type=None, health_reporting=None, id=None, ip_anchored=None, is_cname_enabled=None, microtenant_id=None, microtenant_name=None, name=None, passive_health_enabled=None, segment_group_id=None, segment_group_name=None, server_groups=None, sra_apps=None, tcp_port_range=None, tcp_port_ranges=None, udp_port_range=None, udp_port_ranges=None):
        if bypass_type and not isinstance(bypass_type, str):
            raise TypeError("Expected argument 'bypass_type' to be a str")
        pulumi.set(__self__, "bypass_type", bypass_type)
        if config_space and not isinstance(config_space, str):
            raise TypeError("Expected argument 'config_space' to be a str")
        pulumi.set(__self__, "config_space", config_space)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if domain_names and not isinstance(domain_names, list):
            raise TypeError("Expected argument 'domain_names' to be a list")
        pulumi.set(__self__, "domain_names", domain_names)
        if double_encrypt and not isinstance(double_encrypt, bool):
            raise TypeError("Expected argument 'double_encrypt' to be a bool")
        pulumi.set(__self__, "double_encrypt", double_encrypt)
        if enabled and not isinstance(enabled, bool):
            raise TypeError("Expected argument 'enabled' to be a bool")
        pulumi.set(__self__, "enabled", enabled)
        if health_check_type and not isinstance(health_check_type, str):
            raise TypeError("Expected argument 'health_check_type' to be a str")
        pulumi.set(__self__, "health_check_type", health_check_type)
        if health_reporting and not isinstance(health_reporting, str):
            raise TypeError("Expected argument 'health_reporting' to be a str")
        pulumi.set(__self__, "health_reporting", health_reporting)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ip_anchored and not isinstance(ip_anchored, bool):
            raise TypeError("Expected argument 'ip_anchored' to be a bool")
        pulumi.set(__self__, "ip_anchored", ip_anchored)
        if is_cname_enabled and not isinstance(is_cname_enabled, bool):
            raise TypeError("Expected argument 'is_cname_enabled' to be a bool")
        pulumi.set(__self__, "is_cname_enabled", is_cname_enabled)
        if microtenant_id and not isinstance(microtenant_id, str):
            raise TypeError("Expected argument 'microtenant_id' to be a str")
        pulumi.set(__self__, "microtenant_id", microtenant_id)
        if microtenant_name and not isinstance(microtenant_name, str):
            raise TypeError("Expected argument 'microtenant_name' to be a str")
        pulumi.set(__self__, "microtenant_name", microtenant_name)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if passive_health_enabled and not isinstance(passive_health_enabled, bool):
            raise TypeError("Expected argument 'passive_health_enabled' to be a bool")
        pulumi.set(__self__, "passive_health_enabled", passive_health_enabled)
        if segment_group_id and not isinstance(segment_group_id, str):
            raise TypeError("Expected argument 'segment_group_id' to be a str")
        pulumi.set(__self__, "segment_group_id", segment_group_id)
        if segment_group_name and not isinstance(segment_group_name, str):
            raise TypeError("Expected argument 'segment_group_name' to be a str")
        pulumi.set(__self__, "segment_group_name", segment_group_name)
        if server_groups and not isinstance(server_groups, list):
            raise TypeError("Expected argument 'server_groups' to be a list")
        pulumi.set(__self__, "server_groups", server_groups)
        if sra_apps and not isinstance(sra_apps, list):
            raise TypeError("Expected argument 'sra_apps' to be a list")
        pulumi.set(__self__, "sra_apps", sra_apps)
        if tcp_port_range and not isinstance(tcp_port_range, list):
            raise TypeError("Expected argument 'tcp_port_range' to be a list")
        pulumi.set(__self__, "tcp_port_range", tcp_port_range)
        if tcp_port_ranges and not isinstance(tcp_port_ranges, list):
            raise TypeError("Expected argument 'tcp_port_ranges' to be a list")
        pulumi.set(__self__, "tcp_port_ranges", tcp_port_ranges)
        if udp_port_range and not isinstance(udp_port_range, list):
            raise TypeError("Expected argument 'udp_port_range' to be a list")
        pulumi.set(__self__, "udp_port_range", udp_port_range)
        if udp_port_ranges and not isinstance(udp_port_ranges, list):
            raise TypeError("Expected argument 'udp_port_ranges' to be a list")
        pulumi.set(__self__, "udp_port_ranges", udp_port_ranges)

    @_builtins.property
    @pulumi.getter(name="bypassType")
    def bypass_type(self) -> _builtins.str:
        return pulumi.get(self, "bypass_type")

    @_builtins.property
    @pulumi.getter(name="configSpace")
    def config_space(self) -> _builtins.str:
        return pulumi.get(self, "config_space")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter(name="doubleEncrypt")
    def double_encrypt(self) -> _builtins.bool:
        return pulumi.get(self, "double_encrypt")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> _builtins.str:
        return pulumi.get(self, "health_check_type")

    @_builtins.property
    @pulumi.getter(name="healthReporting")
    def health_reporting(self) -> _builtins.str:
        return pulumi.get(self, "health_reporting")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAnchored")
    def ip_anchored(self) -> _builtins.bool:
        return pulumi.get(self, "ip_anchored")

    @_builtins.property
    @pulumi.getter(name="isCnameEnabled")
    def is_cname_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_cname_enabled")

    @_builtins.property
    @pulumi.getter(name="microtenantId")
    def microtenant_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "microtenant_id")

    @_builtins.property
    @pulumi.getter(name="microtenantName")
    def microtenant_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "microtenant_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="passiveHealthEnabled")
    def passive_health_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "passive_health_enabled")

    @_builtins.property
    @pulumi.getter(name="segmentGroupId")
    def segment_group_id(self) -> _builtins.str:
        return pulumi.get(self, "segment_group_id")

    @_builtins.property
    @pulumi.getter(name="segmentGroupName")
    def segment_group_name(self) -> _builtins.str:
        return pulumi.get(self, "segment_group_name")

    @_builtins.property
    @pulumi.getter(name="serverGroups")
    def server_groups(self) -> Sequence['outputs.GetApplicationSegmentPRAServerGroupResult']:
        return pulumi.get(self, "server_groups")

    @_builtins.property
    @pulumi.getter(name="sraApps")
    def sra_apps(self) -> Sequence['outputs.GetApplicationSegmentPRASraAppResult']:
        return pulumi.get(self, "sra_apps")

    @_builtins.property
    @pulumi.getter(name="tcpPortRange")
    def tcp_port_range(self) -> Sequence['outputs.GetApplicationSegmentPRATcpPortRangeResult']:
        return pulumi.get(self, "tcp_port_range")

    @_builtins.property
    @pulumi.getter(name="tcpPortRanges")
    def tcp_port_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tcp_port_ranges")

    @_builtins.property
    @pulumi.getter(name="udpPortRange")
    def udp_port_range(self) -> Sequence['outputs.GetApplicationSegmentPRAUdpPortRangeResult']:
        return pulumi.get(self, "udp_port_range")

    @_builtins.property
    @pulumi.getter(name="udpPortRanges")
    def udp_port_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "udp_port_ranges")


class AwaitableGetApplicationSegmentPRAResult(GetApplicationSegmentPRAResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetApplicationSegmentPRAResult(
            bypass_type=self.bypass_type,
            config_space=self.config_space,
            description=self.description,
            domain_names=self.domain_names,
            double_encrypt=self.double_encrypt,
            enabled=self.enabled,
            health_check_type=self.health_check_type,
            health_reporting=self.health_reporting,
            id=self.id,
            ip_anchored=self.ip_anchored,
            is_cname_enabled=self.is_cname_enabled,
            microtenant_id=self.microtenant_id,
            microtenant_name=self.microtenant_name,
            name=self.name,
            passive_health_enabled=self.passive_health_enabled,
            segment_group_id=self.segment_group_id,
            segment_group_name=self.segment_group_name,
            server_groups=self.server_groups,
            sra_apps=self.sra_apps,
            tcp_port_range=self.tcp_port_range,
            tcp_port_ranges=self.tcp_port_ranges,
            udp_port_range=self.udp_port_range,
            udp_port_ranges=self.udp_port_ranges)


def get_application_segment_pra(id: Optional[_builtins.str] = None,
                                microtenant_id: Optional[_builtins.str] = None,
                                microtenant_name: Optional[_builtins.str] = None,
                                name: Optional[_builtins.str] = None,
                                tcp_port_range: Optional[Sequence[Union['GetApplicationSegmentPRATcpPortRangeArgs', 'GetApplicationSegmentPRATcpPortRangeArgsDict']]] = None,
                                udp_port_range: Optional[Sequence[Union['GetApplicationSegmentPRAUdpPortRangeArgs', 'GetApplicationSegmentPRAUdpPortRangeArgsDict']]] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetApplicationSegmentPRAResult:
    """
    * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
    * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)

    Use the **zpa_application_segment_pra** data source to get information about an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.

    **NOTE:** To ensure consistent search results across data sources, please avoid using multiple spaces or special characters in your search queries.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_zpa as zpa

    # ZPA Application Segment Data Source
    this = zpa.get_application_segment_pra(name="PRA_Example")
    ```

    ```python
    import pulumi
    import pulumi_zpa as zpa

    # ZPA Application Segment Data Source
    this = zpa.get_application_segment_pra(id="123456789")
    ```
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['microtenantId'] = microtenant_id
    __args__['microtenantName'] = microtenant_name
    __args__['name'] = name
    __args__['tcpPortRange'] = tcp_port_range
    __args__['udpPortRange'] = udp_port_range
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zpa:index/getApplicationSegmentPRA:getApplicationSegmentPRA', __args__, opts=opts, typ=GetApplicationSegmentPRAResult).value

    return AwaitableGetApplicationSegmentPRAResult(
        bypass_type=pulumi.get(__ret__, 'bypass_type'),
        config_space=pulumi.get(__ret__, 'config_space'),
        description=pulumi.get(__ret__, 'description'),
        domain_names=pulumi.get(__ret__, 'domain_names'),
        double_encrypt=pulumi.get(__ret__, 'double_encrypt'),
        enabled=pulumi.get(__ret__, 'enabled'),
        health_check_type=pulumi.get(__ret__, 'health_check_type'),
        health_reporting=pulumi.get(__ret__, 'health_reporting'),
        id=pulumi.get(__ret__, 'id'),
        ip_anchored=pulumi.get(__ret__, 'ip_anchored'),
        is_cname_enabled=pulumi.get(__ret__, 'is_cname_enabled'),
        microtenant_id=pulumi.get(__ret__, 'microtenant_id'),
        microtenant_name=pulumi.get(__ret__, 'microtenant_name'),
        name=pulumi.get(__ret__, 'name'),
        passive_health_enabled=pulumi.get(__ret__, 'passive_health_enabled'),
        segment_group_id=pulumi.get(__ret__, 'segment_group_id'),
        segment_group_name=pulumi.get(__ret__, 'segment_group_name'),
        server_groups=pulumi.get(__ret__, 'server_groups'),
        sra_apps=pulumi.get(__ret__, 'sra_apps'),
        tcp_port_range=pulumi.get(__ret__, 'tcp_port_range'),
        tcp_port_ranges=pulumi.get(__ret__, 'tcp_port_ranges'),
        udp_port_range=pulumi.get(__ret__, 'udp_port_range'),
        udp_port_ranges=pulumi.get(__ret__, 'udp_port_ranges'))
def get_application_segment_pra_output(id: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                       microtenant_id: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                       microtenant_name: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                       name: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                       tcp_port_range: Optional[pulumi.Input[Optional[Sequence[Union['GetApplicationSegmentPRATcpPortRangeArgs', 'GetApplicationSegmentPRATcpPortRangeArgsDict']]]]] = None,
                                       udp_port_range: Optional[pulumi.Input[Optional[Sequence[Union['GetApplicationSegmentPRAUdpPortRangeArgs', 'GetApplicationSegmentPRAUdpPortRangeArgsDict']]]]] = None,
                                       opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetApplicationSegmentPRAResult]:
    """
    * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
    * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)

    Use the **zpa_application_segment_pra** data source to get information about an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.

    **NOTE:** To ensure consistent search results across data sources, please avoid using multiple spaces or special characters in your search queries.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_zpa as zpa

    # ZPA Application Segment Data Source
    this = zpa.get_application_segment_pra(name="PRA_Example")
    ```

    ```python
    import pulumi
    import pulumi_zpa as zpa

    # ZPA Application Segment Data Source
    this = zpa.get_application_segment_pra(id="123456789")
    ```
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['microtenantId'] = microtenant_id
    __args__['microtenantName'] = microtenant_name
    __args__['name'] = name
    __args__['tcpPortRange'] = tcp_port_range
    __args__['udpPortRange'] = udp_port_range
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('zpa:index/getApplicationSegmentPRA:getApplicationSegmentPRA', __args__, opts=opts, typ=GetApplicationSegmentPRAResult)
    return __ret__.apply(lambda __response__: GetApplicationSegmentPRAResult(
        bypass_type=pulumi.get(__response__, 'bypass_type'),
        config_space=pulumi.get(__response__, 'config_space'),
        description=pulumi.get(__response__, 'description'),
        domain_names=pulumi.get(__response__, 'domain_names'),
        double_encrypt=pulumi.get(__response__, 'double_encrypt'),
        enabled=pulumi.get(__response__, 'enabled'),
        health_check_type=pulumi.get(__response__, 'health_check_type'),
        health_reporting=pulumi.get(__response__, 'health_reporting'),
        id=pulumi.get(__response__, 'id'),
        ip_anchored=pulumi.get(__response__, 'ip_anchored'),
        is_cname_enabled=pulumi.get(__response__, 'is_cname_enabled'),
        microtenant_id=pulumi.get(__response__, 'microtenant_id'),
        microtenant_name=pulumi.get(__response__, 'microtenant_name'),
        name=pulumi.get(__response__, 'name'),
        passive_health_enabled=pulumi.get(__response__, 'passive_health_enabled'),
        segment_group_id=pulumi.get(__response__, 'segment_group_id'),
        segment_group_name=pulumi.get(__response__, 'segment_group_name'),
        server_groups=pulumi.get(__response__, 'server_groups'),
        sra_apps=pulumi.get(__response__, 'sra_apps'),
        tcp_port_range=pulumi.get(__response__, 'tcp_port_range'),
        tcp_port_ranges=pulumi.get(__response__, 'tcp_port_ranges'),
        udp_port_range=pulumi.get(__response__, 'udp_port_range'),
        udp_port_ranges=pulumi.get(__response__, 'udp_port_ranges')))
