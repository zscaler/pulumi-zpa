# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ApplicationSegmentPRAArgs', 'ApplicationSegmentPRA']

@pulumi.input_type
class ApplicationSegmentPRAArgs:
    def __init__(__self__, *,
                 domain_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 segment_group_id: pulumi.Input[builtins.str],
                 bypass_on_reauth: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_type: Optional[pulumi.Input[builtins.str]] = None,
                 common_apps_dto: Optional[pulumi.Input['ApplicationSegmentPRACommonAppsDtoArgs']] = None,
                 config_space: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 double_encrypt: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fqdn_dns_check: Optional[pulumi.Input[builtins.bool]] = None,
                 health_check_type: Optional[pulumi.Input[builtins.str]] = None,
                 health_reporting: Optional[pulumi.Input[builtins.str]] = None,
                 icmp_access_type: Optional[pulumi.Input[builtins.str]] = None,
                 ip_anchored: Optional[pulumi.Input[builtins.bool]] = None,
                 is_cname_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_incomplete_dr_config: Optional[pulumi.Input[builtins.bool]] = None,
                 microtenant_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 passive_health_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 select_connector_close_to_app: Optional[pulumi.Input[builtins.bool]] = None,
                 server_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAServerGroupArgs']]]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[builtins.str]] = None,
                 tcp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]]] = None,
                 tcp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 udp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]]] = None,
                 udp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 use_in_dr_mode: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The set of arguments for constructing a ApplicationSegmentPRA resource.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] domain_names: List of domains and IPs.
        :param pulumi.Input[builtins.str] bypass_type: Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
               The value NEVER indicates the use of the client forwarding policy.
        :param pulumi.Input[builtins.str] description: Description of the application.
        :param pulumi.Input[builtins.bool] double_encrypt: Whether Double Encryption is enabled or disabled for the app.
        :param pulumi.Input[builtins.str] health_reporting: Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        :param pulumi.Input[builtins.bool] is_cname_enabled: Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
               connectors.
        :param pulumi.Input[builtins.str] name: Name of the application.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]] tcp_port_range: tcp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tcp_port_ranges: TCP port ranges used to access the app.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]] udp_port_range: udp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] udp_port_ranges: UDP port ranges used to access the app.
        """
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "segment_group_id", segment_group_id)
        if bypass_on_reauth is not None:
            pulumi.set(__self__, "bypass_on_reauth", bypass_on_reauth)
        if bypass_type is not None:
            pulumi.set(__self__, "bypass_type", bypass_type)
        if common_apps_dto is not None:
            pulumi.set(__self__, "common_apps_dto", common_apps_dto)
        if config_space is not None:
            pulumi.set(__self__, "config_space", config_space)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if double_encrypt is not None:
            pulumi.set(__self__, "double_encrypt", double_encrypt)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn_dns_check is not None:
            pulumi.set(__self__, "fqdn_dns_check", fqdn_dns_check)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if health_reporting is not None:
            pulumi.set(__self__, "health_reporting", health_reporting)
        if icmp_access_type is not None:
            pulumi.set(__self__, "icmp_access_type", icmp_access_type)
        if ip_anchored is not None:
            pulumi.set(__self__, "ip_anchored", ip_anchored)
        if is_cname_enabled is not None:
            pulumi.set(__self__, "is_cname_enabled", is_cname_enabled)
        if is_incomplete_dr_config is not None:
            pulumi.set(__self__, "is_incomplete_dr_config", is_incomplete_dr_config)
        if microtenant_id is not None:
            pulumi.set(__self__, "microtenant_id", microtenant_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if passive_health_enabled is not None:
            pulumi.set(__self__, "passive_health_enabled", passive_health_enabled)
        if select_connector_close_to_app is not None:
            pulumi.set(__self__, "select_connector_close_to_app", select_connector_close_to_app)
        if server_groups is not None:
            pulumi.set(__self__, "server_groups", server_groups)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tcp_port_range is not None:
            pulumi.set(__self__, "tcp_port_range", tcp_port_range)
        if tcp_port_ranges is not None:
            pulumi.set(__self__, "tcp_port_ranges", tcp_port_ranges)
        if udp_port_range is not None:
            pulumi.set(__self__, "udp_port_range", udp_port_range)
        if udp_port_ranges is not None:
            pulumi.set(__self__, "udp_port_ranges", udp_port_ranges)
        if use_in_dr_mode is not None:
            pulumi.set(__self__, "use_in_dr_mode", use_in_dr_mode)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of domains and IPs.
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter(name="segmentGroupId")
    def segment_group_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "segment_group_id")

    @segment_group_id.setter
    def segment_group_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "segment_group_id", value)

    @property
    @pulumi.getter(name="bypassOnReauth")
    def bypass_on_reauth(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "bypass_on_reauth")

    @bypass_on_reauth.setter
    def bypass_on_reauth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bypass_on_reauth", value)

    @property
    @pulumi.getter(name="bypassType")
    def bypass_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
        The value NEVER indicates the use of the client forwarding policy.
        """
        return pulumi.get(self, "bypass_type")

    @bypass_type.setter
    def bypass_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bypass_type", value)

    @property
    @pulumi.getter(name="commonAppsDto")
    def common_apps_dto(self) -> Optional[pulumi.Input['ApplicationSegmentPRACommonAppsDtoArgs']]:
        return pulumi.get(self, "common_apps_dto")

    @common_apps_dto.setter
    def common_apps_dto(self, value: Optional[pulumi.Input['ApplicationSegmentPRACommonAppsDtoArgs']]):
        pulumi.set(self, "common_apps_dto", value)

    @property
    @pulumi.getter(name="configSpace")
    def config_space(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "config_space")

    @config_space.setter
    def config_space(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_space", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the application.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="doubleEncrypt")
    def double_encrypt(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Double Encryption is enabled or disabled for the app.
        """
        return pulumi.get(self, "double_encrypt")

    @double_encrypt.setter
    def double_encrypt(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "double_encrypt", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fqdnDnsCheck")
    def fqdn_dns_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "fqdn_dns_check")

    @fqdn_dns_check.setter
    def fqdn_dns_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fqdn_dns_check", value)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "health_check_type")

    @health_check_type.setter
    def health_check_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_type", value)

    @property
    @pulumi.getter(name="healthReporting")
    def health_reporting(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        """
        return pulumi.get(self, "health_reporting")

    @health_reporting.setter
    def health_reporting(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_reporting", value)

    @property
    @pulumi.getter(name="icmpAccessType")
    def icmp_access_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "icmp_access_type")

    @icmp_access_type.setter
    def icmp_access_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "icmp_access_type", value)

    @property
    @pulumi.getter(name="ipAnchored")
    def ip_anchored(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "ip_anchored")

    @ip_anchored.setter
    def ip_anchored(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ip_anchored", value)

    @property
    @pulumi.getter(name="isCnameEnabled")
    def is_cname_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
        connectors.
        """
        return pulumi.get(self, "is_cname_enabled")

    @is_cname_enabled.setter
    def is_cname_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_cname_enabled", value)

    @property
    @pulumi.getter(name="isIncompleteDrConfig")
    def is_incomplete_dr_config(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_incomplete_dr_config")

    @is_incomplete_dr_config.setter
    def is_incomplete_dr_config(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_incomplete_dr_config", value)

    @property
    @pulumi.getter(name="microtenantId")
    def microtenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "microtenant_id")

    @microtenant_id.setter
    def microtenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microtenant_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="passiveHealthEnabled")
    def passive_health_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "passive_health_enabled")

    @passive_health_enabled.setter
    def passive_health_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "passive_health_enabled", value)

    @property
    @pulumi.getter(name="selectConnectorCloseToApp")
    def select_connector_close_to_app(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "select_connector_close_to_app")

    @select_connector_close_to_app.setter
    def select_connector_close_to_app(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "select_connector_close_to_app", value)

    @property
    @pulumi.getter(name="serverGroups")
    def server_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAServerGroupArgs']]]]:
        return pulumi.get(self, "server_groups")

    @server_groups.setter
    def server_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAServerGroupArgs']]]]):
        pulumi.set(self, "server_groups", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tcpPortRange")
    def tcp_port_range(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]]]:
        """
        tcp port range
        """
        return pulumi.get(self, "tcp_port_range")

    @tcp_port_range.setter
    def tcp_port_range(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]]]):
        pulumi.set(self, "tcp_port_range", value)

    @property
    @pulumi.getter(name="tcpPortRanges")
    def tcp_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        TCP port ranges used to access the app.
        """
        return pulumi.get(self, "tcp_port_ranges")

    @tcp_port_ranges.setter
    def tcp_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tcp_port_ranges", value)

    @property
    @pulumi.getter(name="udpPortRange")
    def udp_port_range(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]]]:
        """
        udp port range
        """
        return pulumi.get(self, "udp_port_range")

    @udp_port_range.setter
    def udp_port_range(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]]]):
        pulumi.set(self, "udp_port_range", value)

    @property
    @pulumi.getter(name="udpPortRanges")
    def udp_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        UDP port ranges used to access the app.
        """
        return pulumi.get(self, "udp_port_ranges")

    @udp_port_ranges.setter
    def udp_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "udp_port_ranges", value)

    @property
    @pulumi.getter(name="useInDrMode")
    def use_in_dr_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "use_in_dr_mode")

    @use_in_dr_mode.setter
    def use_in_dr_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_in_dr_mode", value)


@pulumi.input_type
class _ApplicationSegmentPRAState:
    def __init__(__self__, *,
                 bypass_on_reauth: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_type: Optional[pulumi.Input[builtins.str]] = None,
                 common_apps_dto: Optional[pulumi.Input['ApplicationSegmentPRACommonAppsDtoArgs']] = None,
                 config_space: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 double_encrypt: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fqdn_dns_check: Optional[pulumi.Input[builtins.bool]] = None,
                 health_check_type: Optional[pulumi.Input[builtins.str]] = None,
                 health_reporting: Optional[pulumi.Input[builtins.str]] = None,
                 icmp_access_type: Optional[pulumi.Input[builtins.str]] = None,
                 ip_anchored: Optional[pulumi.Input[builtins.bool]] = None,
                 is_cname_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_incomplete_dr_config: Optional[pulumi.Input[builtins.bool]] = None,
                 microtenant_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 passive_health_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 segment_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 select_connector_close_to_app: Optional[pulumi.Input[builtins.bool]] = None,
                 server_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAServerGroupArgs']]]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[builtins.str]] = None,
                 tcp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]]] = None,
                 tcp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 udp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]]] = None,
                 udp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 use_in_dr_mode: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Input properties used for looking up and filtering ApplicationSegmentPRA resources.
        :param pulumi.Input[builtins.str] bypass_type: Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
               The value NEVER indicates the use of the client forwarding policy.
        :param pulumi.Input[builtins.str] description: Description of the application.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] domain_names: List of domains and IPs.
        :param pulumi.Input[builtins.bool] double_encrypt: Whether Double Encryption is enabled or disabled for the app.
        :param pulumi.Input[builtins.str] health_reporting: Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        :param pulumi.Input[builtins.bool] is_cname_enabled: Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
               connectors.
        :param pulumi.Input[builtins.str] name: Name of the application.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]] tcp_port_range: tcp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tcp_port_ranges: TCP port ranges used to access the app.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]] udp_port_range: udp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] udp_port_ranges: UDP port ranges used to access the app.
        """
        if bypass_on_reauth is not None:
            pulumi.set(__self__, "bypass_on_reauth", bypass_on_reauth)
        if bypass_type is not None:
            pulumi.set(__self__, "bypass_type", bypass_type)
        if common_apps_dto is not None:
            pulumi.set(__self__, "common_apps_dto", common_apps_dto)
        if config_space is not None:
            pulumi.set(__self__, "config_space", config_space)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if double_encrypt is not None:
            pulumi.set(__self__, "double_encrypt", double_encrypt)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn_dns_check is not None:
            pulumi.set(__self__, "fqdn_dns_check", fqdn_dns_check)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if health_reporting is not None:
            pulumi.set(__self__, "health_reporting", health_reporting)
        if icmp_access_type is not None:
            pulumi.set(__self__, "icmp_access_type", icmp_access_type)
        if ip_anchored is not None:
            pulumi.set(__self__, "ip_anchored", ip_anchored)
        if is_cname_enabled is not None:
            pulumi.set(__self__, "is_cname_enabled", is_cname_enabled)
        if is_incomplete_dr_config is not None:
            pulumi.set(__self__, "is_incomplete_dr_config", is_incomplete_dr_config)
        if microtenant_id is not None:
            pulumi.set(__self__, "microtenant_id", microtenant_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if passive_health_enabled is not None:
            pulumi.set(__self__, "passive_health_enabled", passive_health_enabled)
        if segment_group_id is not None:
            pulumi.set(__self__, "segment_group_id", segment_group_id)
        if select_connector_close_to_app is not None:
            pulumi.set(__self__, "select_connector_close_to_app", select_connector_close_to_app)
        if server_groups is not None:
            pulumi.set(__self__, "server_groups", server_groups)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tcp_port_range is not None:
            pulumi.set(__self__, "tcp_port_range", tcp_port_range)
        if tcp_port_ranges is not None:
            pulumi.set(__self__, "tcp_port_ranges", tcp_port_ranges)
        if udp_port_range is not None:
            pulumi.set(__self__, "udp_port_range", udp_port_range)
        if udp_port_ranges is not None:
            pulumi.set(__self__, "udp_port_ranges", udp_port_ranges)
        if use_in_dr_mode is not None:
            pulumi.set(__self__, "use_in_dr_mode", use_in_dr_mode)

    @property
    @pulumi.getter(name="bypassOnReauth")
    def bypass_on_reauth(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "bypass_on_reauth")

    @bypass_on_reauth.setter
    def bypass_on_reauth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bypass_on_reauth", value)

    @property
    @pulumi.getter(name="bypassType")
    def bypass_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
        The value NEVER indicates the use of the client forwarding policy.
        """
        return pulumi.get(self, "bypass_type")

    @bypass_type.setter
    def bypass_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bypass_type", value)

    @property
    @pulumi.getter(name="commonAppsDto")
    def common_apps_dto(self) -> Optional[pulumi.Input['ApplicationSegmentPRACommonAppsDtoArgs']]:
        return pulumi.get(self, "common_apps_dto")

    @common_apps_dto.setter
    def common_apps_dto(self, value: Optional[pulumi.Input['ApplicationSegmentPRACommonAppsDtoArgs']]):
        pulumi.set(self, "common_apps_dto", value)

    @property
    @pulumi.getter(name="configSpace")
    def config_space(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "config_space")

    @config_space.setter
    def config_space(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_space", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the application.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of domains and IPs.
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter(name="doubleEncrypt")
    def double_encrypt(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Double Encryption is enabled or disabled for the app.
        """
        return pulumi.get(self, "double_encrypt")

    @double_encrypt.setter
    def double_encrypt(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "double_encrypt", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fqdnDnsCheck")
    def fqdn_dns_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "fqdn_dns_check")

    @fqdn_dns_check.setter
    def fqdn_dns_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fqdn_dns_check", value)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "health_check_type")

    @health_check_type.setter
    def health_check_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_type", value)

    @property
    @pulumi.getter(name="healthReporting")
    def health_reporting(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        """
        return pulumi.get(self, "health_reporting")

    @health_reporting.setter
    def health_reporting(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_reporting", value)

    @property
    @pulumi.getter(name="icmpAccessType")
    def icmp_access_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "icmp_access_type")

    @icmp_access_type.setter
    def icmp_access_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "icmp_access_type", value)

    @property
    @pulumi.getter(name="ipAnchored")
    def ip_anchored(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "ip_anchored")

    @ip_anchored.setter
    def ip_anchored(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ip_anchored", value)

    @property
    @pulumi.getter(name="isCnameEnabled")
    def is_cname_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
        connectors.
        """
        return pulumi.get(self, "is_cname_enabled")

    @is_cname_enabled.setter
    def is_cname_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_cname_enabled", value)

    @property
    @pulumi.getter(name="isIncompleteDrConfig")
    def is_incomplete_dr_config(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_incomplete_dr_config")

    @is_incomplete_dr_config.setter
    def is_incomplete_dr_config(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_incomplete_dr_config", value)

    @property
    @pulumi.getter(name="microtenantId")
    def microtenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "microtenant_id")

    @microtenant_id.setter
    def microtenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microtenant_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="passiveHealthEnabled")
    def passive_health_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "passive_health_enabled")

    @passive_health_enabled.setter
    def passive_health_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "passive_health_enabled", value)

    @property
    @pulumi.getter(name="segmentGroupId")
    def segment_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "segment_group_id")

    @segment_group_id.setter
    def segment_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "segment_group_id", value)

    @property
    @pulumi.getter(name="selectConnectorCloseToApp")
    def select_connector_close_to_app(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "select_connector_close_to_app")

    @select_connector_close_to_app.setter
    def select_connector_close_to_app(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "select_connector_close_to_app", value)

    @property
    @pulumi.getter(name="serverGroups")
    def server_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAServerGroupArgs']]]]:
        return pulumi.get(self, "server_groups")

    @server_groups.setter
    def server_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAServerGroupArgs']]]]):
        pulumi.set(self, "server_groups", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tcpPortRange")
    def tcp_port_range(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]]]:
        """
        tcp port range
        """
        return pulumi.get(self, "tcp_port_range")

    @tcp_port_range.setter
    def tcp_port_range(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRATcpPortRangeArgs']]]]):
        pulumi.set(self, "tcp_port_range", value)

    @property
    @pulumi.getter(name="tcpPortRanges")
    def tcp_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        TCP port ranges used to access the app.
        """
        return pulumi.get(self, "tcp_port_ranges")

    @tcp_port_ranges.setter
    def tcp_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tcp_port_ranges", value)

    @property
    @pulumi.getter(name="udpPortRange")
    def udp_port_range(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]]]:
        """
        udp port range
        """
        return pulumi.get(self, "udp_port_range")

    @udp_port_range.setter
    def udp_port_range(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationSegmentPRAUdpPortRangeArgs']]]]):
        pulumi.set(self, "udp_port_range", value)

    @property
    @pulumi.getter(name="udpPortRanges")
    def udp_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        UDP port ranges used to access the app.
        """
        return pulumi.get(self, "udp_port_ranges")

    @udp_port_ranges.setter
    def udp_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "udp_port_ranges", value)

    @property
    @pulumi.getter(name="useInDrMode")
    def use_in_dr_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "use_in_dr_mode")

    @use_in_dr_mode.setter
    def use_in_dr_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_in_dr_mode", value)


@pulumi.type_token("zpa:index/applicationSegmentPRA:ApplicationSegmentPRA")
class ApplicationSegmentPRA(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 bypass_on_reauth: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_type: Optional[pulumi.Input[builtins.str]] = None,
                 common_apps_dto: Optional[pulumi.Input[Union['ApplicationSegmentPRACommonAppsDtoArgs', 'ApplicationSegmentPRACommonAppsDtoArgsDict']]] = None,
                 config_space: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 double_encrypt: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fqdn_dns_check: Optional[pulumi.Input[builtins.bool]] = None,
                 health_check_type: Optional[pulumi.Input[builtins.str]] = None,
                 health_reporting: Optional[pulumi.Input[builtins.str]] = None,
                 icmp_access_type: Optional[pulumi.Input[builtins.str]] = None,
                 ip_anchored: Optional[pulumi.Input[builtins.bool]] = None,
                 is_cname_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_incomplete_dr_config: Optional[pulumi.Input[builtins.bool]] = None,
                 microtenant_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 passive_health_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 segment_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 select_connector_close_to_app: Optional[pulumi.Input[builtins.bool]] = None,
                 server_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAServerGroupArgs', 'ApplicationSegmentPRAServerGroupArgsDict']]]]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[builtins.str]] = None,
                 tcp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRATcpPortRangeArgs', 'ApplicationSegmentPRATcpPortRangeArgsDict']]]]] = None,
                 tcp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 udp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAUdpPortRangeArgs', 'ApplicationSegmentPRAUdpPortRangeArgsDict']]]]] = None,
                 udp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 use_in_dr_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 __props__=None):
        """
        * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
        * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)

        The **zpa_application_segment_pra** resource creates an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.

        ## Example Usage

        ```python
        import pulumi
        import zscaler_pulumi_zpa as zpa

        this = zpa.ApplicationSegmentPRA("this",
            description="PRA_Example",
            enabled=True,
            health_reporting="ON_ACCESS",
            bypass_type="NEVER",
            is_cname_enabled=True,
            tcp_port_ranges=[
                "22",
                "22",
                "3389",
                "3389",
            ],
            domain_names=[
                "ssh_pra.example.com",
                "rdp_pra.example.com",
            ],
            segment_group_id=zpa_segment_group["this"]["id"],
            server_groups=[{
                "ids": [zpa_server_group["this"]["id"]],
            }],
            common_apps_dto={
                "apps_configs": [
                    {
                        "domain": "ssh_pra.example.com",
                        "application_protocol": "SSH",
                        "application_port": "22",
                        "enabled": True,
                        "app_types": ["SECURE_REMOTE_ACCESS"],
                    },
                    {
                        "domain": "rdp_pra.example.com",
                        "application_protocol": "RDP",
                        "connection_security": "ANY",
                        "application_port": "3389",
                        "enabled": True,
                        "app_types": ["SECURE_REMOTE_ACCESS"],
                    },
                ],
            })
        ```

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        Application Segment can be imported by using `<APPLICATION SEGMENT ID>` or `<APPLICATION SEGMENT NAME>` as the import ID.

        ```sh
        $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_id>
        ```

        or

        ```sh
        $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_name>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.str] bypass_type: Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
               The value NEVER indicates the use of the client forwarding policy.
        :param pulumi.Input[builtins.str] description: Description of the application.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] domain_names: List of domains and IPs.
        :param pulumi.Input[builtins.bool] double_encrypt: Whether Double Encryption is enabled or disabled for the app.
        :param pulumi.Input[builtins.str] health_reporting: Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        :param pulumi.Input[builtins.bool] is_cname_enabled: Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
               connectors.
        :param pulumi.Input[builtins.str] name: Name of the application.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRATcpPortRangeArgs', 'ApplicationSegmentPRATcpPortRangeArgsDict']]]] tcp_port_range: tcp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tcp_port_ranges: TCP port ranges used to access the app.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAUdpPortRangeArgs', 'ApplicationSegmentPRAUdpPortRangeArgsDict']]]] udp_port_range: udp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] udp_port_ranges: UDP port ranges used to access the app.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ApplicationSegmentPRAArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        * [Official documentation](https://help.zscaler.com/zpa/about-privileged-remote-access-applications)
        * [API documentation](https://help.zscaler.com/zpa/configuring-application-segments-using-api)

        The **zpa_application_segment_pra** resource creates an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.

        ## Example Usage

        ```python
        import pulumi
        import zscaler_pulumi_zpa as zpa

        this = zpa.ApplicationSegmentPRA("this",
            description="PRA_Example",
            enabled=True,
            health_reporting="ON_ACCESS",
            bypass_type="NEVER",
            is_cname_enabled=True,
            tcp_port_ranges=[
                "22",
                "22",
                "3389",
                "3389",
            ],
            domain_names=[
                "ssh_pra.example.com",
                "rdp_pra.example.com",
            ],
            segment_group_id=zpa_segment_group["this"]["id"],
            server_groups=[{
                "ids": [zpa_server_group["this"]["id"]],
            }],
            common_apps_dto={
                "apps_configs": [
                    {
                        "domain": "ssh_pra.example.com",
                        "application_protocol": "SSH",
                        "application_port": "22",
                        "enabled": True,
                        "app_types": ["SECURE_REMOTE_ACCESS"],
                    },
                    {
                        "domain": "rdp_pra.example.com",
                        "application_protocol": "RDP",
                        "connection_security": "ANY",
                        "application_port": "3389",
                        "enabled": True,
                        "app_types": ["SECURE_REMOTE_ACCESS"],
                    },
                ],
            })
        ```

        ## Import

        Zscaler offers a dedicated tool called Zscaler-Terraformer to allow the automated import of ZPA configurations into Terraform-compliant HashiCorp Configuration Language.

        Visit

        Application Segment can be imported by using `<APPLICATION SEGMENT ID>` or `<APPLICATION SEGMENT NAME>` as the import ID.

        ```sh
        $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_id>
        ```

        or

        ```sh
        $ pulumi import zpa:index/applicationSegmentPRA:ApplicationSegmentPRA example <application_segment_name>
        ```

        :param str resource_name: The name of the resource.
        :param ApplicationSegmentPRAArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ApplicationSegmentPRAArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 bypass_on_reauth: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_type: Optional[pulumi.Input[builtins.str]] = None,
                 common_apps_dto: Optional[pulumi.Input[Union['ApplicationSegmentPRACommonAppsDtoArgs', 'ApplicationSegmentPRACommonAppsDtoArgsDict']]] = None,
                 config_space: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 double_encrypt: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fqdn_dns_check: Optional[pulumi.Input[builtins.bool]] = None,
                 health_check_type: Optional[pulumi.Input[builtins.str]] = None,
                 health_reporting: Optional[pulumi.Input[builtins.str]] = None,
                 icmp_access_type: Optional[pulumi.Input[builtins.str]] = None,
                 ip_anchored: Optional[pulumi.Input[builtins.bool]] = None,
                 is_cname_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_incomplete_dr_config: Optional[pulumi.Input[builtins.bool]] = None,
                 microtenant_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 passive_health_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 segment_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 select_connector_close_to_app: Optional[pulumi.Input[builtins.bool]] = None,
                 server_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAServerGroupArgs', 'ApplicationSegmentPRAServerGroupArgsDict']]]]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[builtins.str]] = None,
                 tcp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRATcpPortRangeArgs', 'ApplicationSegmentPRATcpPortRangeArgsDict']]]]] = None,
                 tcp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 udp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAUdpPortRangeArgs', 'ApplicationSegmentPRAUdpPortRangeArgsDict']]]]] = None,
                 udp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 use_in_dr_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ApplicationSegmentPRAArgs.__new__(ApplicationSegmentPRAArgs)

            __props__.__dict__["bypass_on_reauth"] = bypass_on_reauth
            __props__.__dict__["bypass_type"] = bypass_type
            __props__.__dict__["common_apps_dto"] = common_apps_dto
            __props__.__dict__["config_space"] = config_space
            __props__.__dict__["description"] = description
            if domain_names is None and not opts.urn:
                raise TypeError("Missing required property 'domain_names'")
            __props__.__dict__["domain_names"] = domain_names
            __props__.__dict__["double_encrypt"] = double_encrypt
            __props__.__dict__["enabled"] = enabled
            __props__.__dict__["fqdn_dns_check"] = fqdn_dns_check
            __props__.__dict__["health_check_type"] = health_check_type
            __props__.__dict__["health_reporting"] = health_reporting
            __props__.__dict__["icmp_access_type"] = icmp_access_type
            __props__.__dict__["ip_anchored"] = ip_anchored
            __props__.__dict__["is_cname_enabled"] = is_cname_enabled
            __props__.__dict__["is_incomplete_dr_config"] = is_incomplete_dr_config
            __props__.__dict__["microtenant_id"] = microtenant_id
            __props__.__dict__["name"] = name
            __props__.__dict__["passive_health_enabled"] = passive_health_enabled
            if segment_group_id is None and not opts.urn:
                raise TypeError("Missing required property 'segment_group_id'")
            __props__.__dict__["segment_group_id"] = segment_group_id
            __props__.__dict__["select_connector_close_to_app"] = select_connector_close_to_app
            __props__.__dict__["server_groups"] = server_groups
            __props__.__dict__["tcp_keep_alive"] = tcp_keep_alive
            __props__.__dict__["tcp_port_range"] = tcp_port_range
            __props__.__dict__["tcp_port_ranges"] = tcp_port_ranges
            __props__.__dict__["udp_port_range"] = udp_port_range
            __props__.__dict__["udp_port_ranges"] = udp_port_ranges
            __props__.__dict__["use_in_dr_mode"] = use_in_dr_mode
        super(ApplicationSegmentPRA, __self__).__init__(
            'zpa:index/applicationSegmentPRA:ApplicationSegmentPRA',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            bypass_on_reauth: Optional[pulumi.Input[builtins.bool]] = None,
            bypass_type: Optional[pulumi.Input[builtins.str]] = None,
            common_apps_dto: Optional[pulumi.Input[Union['ApplicationSegmentPRACommonAppsDtoArgs', 'ApplicationSegmentPRACommonAppsDtoArgsDict']]] = None,
            config_space: Optional[pulumi.Input[builtins.str]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            double_encrypt: Optional[pulumi.Input[builtins.bool]] = None,
            enabled: Optional[pulumi.Input[builtins.bool]] = None,
            fqdn_dns_check: Optional[pulumi.Input[builtins.bool]] = None,
            health_check_type: Optional[pulumi.Input[builtins.str]] = None,
            health_reporting: Optional[pulumi.Input[builtins.str]] = None,
            icmp_access_type: Optional[pulumi.Input[builtins.str]] = None,
            ip_anchored: Optional[pulumi.Input[builtins.bool]] = None,
            is_cname_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            is_incomplete_dr_config: Optional[pulumi.Input[builtins.bool]] = None,
            microtenant_id: Optional[pulumi.Input[builtins.str]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            passive_health_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            segment_group_id: Optional[pulumi.Input[builtins.str]] = None,
            select_connector_close_to_app: Optional[pulumi.Input[builtins.bool]] = None,
            server_groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAServerGroupArgs', 'ApplicationSegmentPRAServerGroupArgsDict']]]]] = None,
            tcp_keep_alive: Optional[pulumi.Input[builtins.str]] = None,
            tcp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRATcpPortRangeArgs', 'ApplicationSegmentPRATcpPortRangeArgsDict']]]]] = None,
            tcp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            udp_port_range: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAUdpPortRangeArgs', 'ApplicationSegmentPRAUdpPortRangeArgsDict']]]]] = None,
            udp_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            use_in_dr_mode: Optional[pulumi.Input[builtins.bool]] = None) -> 'ApplicationSegmentPRA':
        """
        Get an existing ApplicationSegmentPRA resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.str] bypass_type: Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
               The value NEVER indicates the use of the client forwarding policy.
        :param pulumi.Input[builtins.str] description: Description of the application.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] domain_names: List of domains and IPs.
        :param pulumi.Input[builtins.bool] double_encrypt: Whether Double Encryption is enabled or disabled for the app.
        :param pulumi.Input[builtins.str] health_reporting: Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        :param pulumi.Input[builtins.bool] is_cname_enabled: Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
               connectors.
        :param pulumi.Input[builtins.str] name: Name of the application.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRATcpPortRangeArgs', 'ApplicationSegmentPRATcpPortRangeArgsDict']]]] tcp_port_range: tcp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tcp_port_ranges: TCP port ranges used to access the app.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ApplicationSegmentPRAUdpPortRangeArgs', 'ApplicationSegmentPRAUdpPortRangeArgsDict']]]] udp_port_range: udp port range
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] udp_port_ranges: UDP port ranges used to access the app.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ApplicationSegmentPRAState.__new__(_ApplicationSegmentPRAState)

        __props__.__dict__["bypass_on_reauth"] = bypass_on_reauth
        __props__.__dict__["bypass_type"] = bypass_type
        __props__.__dict__["common_apps_dto"] = common_apps_dto
        __props__.__dict__["config_space"] = config_space
        __props__.__dict__["description"] = description
        __props__.__dict__["domain_names"] = domain_names
        __props__.__dict__["double_encrypt"] = double_encrypt
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["fqdn_dns_check"] = fqdn_dns_check
        __props__.__dict__["health_check_type"] = health_check_type
        __props__.__dict__["health_reporting"] = health_reporting
        __props__.__dict__["icmp_access_type"] = icmp_access_type
        __props__.__dict__["ip_anchored"] = ip_anchored
        __props__.__dict__["is_cname_enabled"] = is_cname_enabled
        __props__.__dict__["is_incomplete_dr_config"] = is_incomplete_dr_config
        __props__.__dict__["microtenant_id"] = microtenant_id
        __props__.__dict__["name"] = name
        __props__.__dict__["passive_health_enabled"] = passive_health_enabled
        __props__.__dict__["segment_group_id"] = segment_group_id
        __props__.__dict__["select_connector_close_to_app"] = select_connector_close_to_app
        __props__.__dict__["server_groups"] = server_groups
        __props__.__dict__["tcp_keep_alive"] = tcp_keep_alive
        __props__.__dict__["tcp_port_range"] = tcp_port_range
        __props__.__dict__["tcp_port_ranges"] = tcp_port_ranges
        __props__.__dict__["udp_port_range"] = udp_port_range
        __props__.__dict__["udp_port_ranges"] = udp_port_ranges
        __props__.__dict__["use_in_dr_mode"] = use_in_dr_mode
        return ApplicationSegmentPRA(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="bypassOnReauth")
    def bypass_on_reauth(self) -> pulumi.Output[builtins.bool]:
        return pulumi.get(self, "bypass_on_reauth")

    @property
    @pulumi.getter(name="bypassType")
    def bypass_type(self) -> pulumi.Output[builtins.str]:
        """
        Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
        The value NEVER indicates the use of the client forwarding policy.
        """
        return pulumi.get(self, "bypass_type")

    @property
    @pulumi.getter(name="commonAppsDto")
    def common_apps_dto(self) -> pulumi.Output['outputs.ApplicationSegmentPRACommonAppsDto']:
        return pulumi.get(self, "common_apps_dto")

    @property
    @pulumi.getter(name="configSpace")
    def config_space(self) -> pulumi.Output[Optional[builtins.str]]:
        return pulumi.get(self, "config_space")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        Description of the application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        List of domains and IPs.
        """
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter(name="doubleEncrypt")
    def double_encrypt(self) -> pulumi.Output[builtins.bool]:
        """
        Whether Double Encryption is enabled or disabled for the app.
        """
        return pulumi.get(self, "double_encrypt")

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fqdnDnsCheck")
    def fqdn_dns_check(self) -> pulumi.Output[Optional[builtins.bool]]:
        return pulumi.get(self, "fqdn_dns_check")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> pulumi.Output[Optional[builtins.str]]:
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="healthReporting")
    def health_reporting(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        """
        return pulumi.get(self, "health_reporting")

    @property
    @pulumi.getter(name="icmpAccessType")
    def icmp_access_type(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "icmp_access_type")

    @property
    @pulumi.getter(name="ipAnchored")
    def ip_anchored(self) -> pulumi.Output[Optional[builtins.bool]]:
        return pulumi.get(self, "ip_anchored")

    @property
    @pulumi.getter(name="isCnameEnabled")
    def is_cname_enabled(self) -> pulumi.Output[builtins.bool]:
        """
        Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
        connectors.
        """
        return pulumi.get(self, "is_cname_enabled")

    @property
    @pulumi.getter(name="isIncompleteDrConfig")
    def is_incomplete_dr_config(self) -> pulumi.Output[builtins.bool]:
        return pulumi.get(self, "is_incomplete_dr_config")

    @property
    @pulumi.getter(name="microtenantId")
    def microtenant_id(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "microtenant_id")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        Name of the application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="passiveHealthEnabled")
    def passive_health_enabled(self) -> pulumi.Output[builtins.bool]:
        return pulumi.get(self, "passive_health_enabled")

    @property
    @pulumi.getter(name="segmentGroupId")
    def segment_group_id(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "segment_group_id")

    @property
    @pulumi.getter(name="selectConnectorCloseToApp")
    def select_connector_close_to_app(self) -> pulumi.Output[Optional[builtins.bool]]:
        return pulumi.get(self, "select_connector_close_to_app")

    @property
    @pulumi.getter(name="serverGroups")
    def server_groups(self) -> pulumi.Output[Optional[Sequence['outputs.ApplicationSegmentPRAServerGroup']]]:
        return pulumi.get(self, "server_groups")

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "tcp_keep_alive")

    @property
    @pulumi.getter(name="tcpPortRange")
    def tcp_port_range(self) -> pulumi.Output[Sequence['outputs.ApplicationSegmentPRATcpPortRange']]:
        """
        tcp port range
        """
        return pulumi.get(self, "tcp_port_range")

    @property
    @pulumi.getter(name="tcpPortRanges")
    def tcp_port_ranges(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        TCP port ranges used to access the app.
        """
        return pulumi.get(self, "tcp_port_ranges")

    @property
    @pulumi.getter(name="udpPortRange")
    def udp_port_range(self) -> pulumi.Output[Sequence['outputs.ApplicationSegmentPRAUdpPortRange']]:
        """
        udp port range
        """
        return pulumi.get(self, "udp_port_range")

    @property
    @pulumi.getter(name="udpPortRanges")
    def udp_port_ranges(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        UDP port ranges used to access the app.
        """
        return pulumi.get(self, "udp_port_ranges")

    @property
    @pulumi.getter(name="useInDrMode")
    def use_in_dr_mode(self) -> pulumi.Output[builtins.bool]:
        return pulumi.get(self, "use_in_dr_mode")

